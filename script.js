// Tableau 3.2.3.1.-B - Usages des groupes A, B3, C, D et F3 - Sans gicleurs
   const tableauGroupesAB3CDF3 = {
       10: {
           "< 3:1": [0, 8, 10, 18, 29, 46, 91, 100],
           "3:1 à 10:1": [0, 8, 12, 21, 33, 50, 96, 100],
           "> 10:1": [0, 11, 18, 32, 48, 68, 100]
       },
       15: {
           "< 3:1": [0, 7, 9, 14, 22, 33, 63, 100],
           "3:1 à 10:1": [0, 8, 10, 17, 25, 37, 67, 100],
           "> 10:1": [0, 10, 15, 26, 39, 53, 87, 100]
       },
       20: {
           "< 3:1": [0, 7, 9, 12, 18, 26, 49, 81, 100],
           "3:1 à 10:1": [0, 8, 10, 15, 21, 30, 53, 85, 100],
           "> 10:1": [0, 9, 14, 23, 33, 45, 72, 100]
       },
       25: {
           "< 3:1": [0, 7, 8, 11, 16, 23, 41, 66, 98, 100],
           "3:1 à 10:1": [0, 8, 9, 13, 19, 26, 45, 70, 100],
           "> 10:1": [0, 9, 13, 21, 30, 39, 62, 90, 100]
       },
       30: {
           "< 3:1": [0, 7, 8, 11, 15, 20, 35, 56, 83, 100],
           "3:1 à 10:1": [0, 7, 9, 12, 17, 23, 39, 61, 88, 100],
           "> 10:1": [0, 8, 12, 19, 27, 36, 56, 79, 100]
       },
       40: {
           "< 3:1": [0, 7, 8, 10, 13, 17, 28, 44, 64, 89, 100],
           "3:1 à 10:1": [0, 7, 8, 11, 15, 20, 32, 48, 69, 93, 100],
           "> 10:1": [0, 8, 11, 17, 24, 31, 47, 66, 88, 100]
       },
       50: {
           "< 3:1": [0, 7, 8, 9, 12, 15, 24, 37, 53, 72, 96, 100],
           "3:1 à 10:1": [0, 7, 8, 10, 14, 18, 28, 41, 57, 77, 100],
           "> 10:1": [0, 8, 10, 15, 21, 28, 41, 57, 76, 97, 100]
       },
       60: {
           "< 3:1": [0, 7, 8, 9, 11, 14, 21, 32, 45, 62, 81, 100],
           "3:1 à 10:1": [0, 7, 8, 10, 13, 16, 25, 36, 49, 66, 85, 100],
           "> 10:1": [0, 8, 10, 14, 20, 25, 38, 51, 67, 85, 100]
       },
       80: {
           "< 3:1": [0, 7, 7, 8, 10, 12, 18, 26, 36, 48, 62, 79, 98, 100],
           "3:1 à 10:1": [0, 7, 8, 9, 11, 14, 21, 29, 40, 52, 67, 84, 100],
           "> 10:1": [0, 8, 9, 13, 17, 22, 32, 44, 56, 70, 86, 100]
       },
       100: {
           "< 3:1": [0, 7, 7, 8, 9, 11, 16, 22, 30, 40, 51, 65, 80, 97, 100],
           "3:1 à 10:1": [0, 7, 8, 9, 11, 13, 18, 25, 34, 44, 56, 69, 84, 100],
           "> 10:1": [0, 7, 9, 12, 16, 20, 29, 39, 49, 61, 74, 89, 100]
       },
       150: {
           "< 3:1": [0, 7, 7, 8, 9, 10, 13, 17, 22, 29, 37, 46, 56, 67, 79, 93, 100],
           "3:1 à 10:1": [0, 7, 7, 8, 10, 11, 15, 20, 26, 33, 41, 50, 60, 71, 84, 97, 100],
           "> 10:1": [0, 7, 8, 11, 13, 17, 24, 31, 39, 48, 57, 68, 79, 91, 100]
       },
       250: {
           "< 3:1": [0, 7, 7, 7, 8, 9, 10, 13, 16, 20, 25, 30, 36, 43, 51, 59, 68, 87, 100],
           "3:1 à 10:1": [0, 7, 7, 8, 9, 10, 12, 15, 19, 24, 28, 34, 40, 47, 55, 63, 72, 92, 100],
           "> 10:1": [0, 7, 8, 9, 11, 14, 19, 24, 30, 36, 43, 50, 57, 65, 73, 82, 92, 100]
       },
       350: {
           "< 3:1": [0, 7, 7, 7, 8, 8, 9, 11, 14, 16, 20, 24, 28, 33, 38, 44, 50, 64, 81, 99, 100],
           "3:1 à 10:1": [0, 7, 7, 8, 8, 9, 11, 13, 16, 19, 23, 27, 32, 37, 42, 48, 55, 69, 85, 100],
           "> 10:1": [0, 7, 8, 9, 10, 12, 16, 21, 25, 30, 36, 41, 47, 53, 59, 66, 73, 88, 100]
       },
       500: {
           "< 3:1": [0, 7, 7, 7, 7, 8, 9, 10, 12, 14, 16, 19, 22, 25, 29, 33, 37, 47, 59, 71, 100],
           "3:1 à 10:1": [0, 7, 7, 7, 8, 8, 10, 12, 14, 16, 19, 22, 25, 29, 33, 37, 41, 52, 63, 76, 100],
           "> 10:1": [0, 7, 7, 8, 9, 11, 14, 18, 22, 25, 30, 34, 38, 43, 48, 53, 58, 70, 82, 96, 100]
       },
       1000: {
           "< 3:1": [0, 7, 7, 7, 7, 7, 8, 9, 9, 10, 12, 13, 14, 16, 18, 20, 22, 27, 33, 39, 58, 82, 100],
           "3:1 à 10:1": [0, 7, 7, 7, 7, 8, 9, 10, 11, 12, 14, 15, 17, 19, 21, 23, 26, 31, 37, 43, 63, 86, 100],
           "> 10:1": [0, 7, 7, 8, 8, 9, 11, 13, 16, 19, 21, 24, 27, 30, 33, 36, 39, 46, 53, 60, 82, 100]
       },
       2000: {
           "< 3:1": [0, 7, 7, 7, 7, 7, 7, 8, 8, 9, 9, 10, 11, 12, 13, 14, 15, 17, 20, 23, 33, 44, 58, 74, 93, 100],
           "3:1 à 10:1": [0, 7, 7, 7, 7, 7, 8, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 23, 27, 37, 49, 63, 79, 97, 100],
           "> 10:1": [0, 7, 7, 7, 8, 8, 9, 11, 12, 14, 16, 18, 19, 21, 23, 25, 27, 32, 36, 40, 53, 66, 82, 99, 100]
       }
   };
   
   // Tableau 3.2.3.1.-C - Usages des groupes E, F1 et F2 - Sans gicleurs
   const tableauGroupesEF1F2 = {
       10: {
           "< 3:1": [0, 4, 5, 9, 15, 23, 46, 77, 100],
           "3:1 à 10:1": [0, 4, 6, 10, 17, 25, 48, 79, 100],
           "> 10:1": [0, 5, 9, 16, 24, 34, 58, 91, 100]
       },
       15: {
           "< 3:1": [0, 4, 5, 7, 11, 16, 32, 53, 79, 100],
           "3:1 à 10:1": [0, 4, 5, 8, 13, 18, 34, 55, 82, 100],
           "> 10:1": [0, 5, 8, 13, 19, 26, 43, 66, 93, 100]
       },
       20: {
           "< 3:1": [0, 4, 4, 6, 9, 13, 25, 40, 61, 85, 100],
           "3:1 à 10:1": [0, 4, 5, 7, 11, 15, 27, 43, 63, 87, 100],
           "> 10:1": [0, 5, 7, 11, 17, 22, 36, 53, 74, 99, 100]
       },
       25: {
           "< 3:1": [0, 4, 4, 6, 8, 11, 20, 33, 49, 69, 92, 100],
           "3:1 à 10:1": [0, 4, 5, 7, 9, 13, 22, 35, 51, 71, 94, 100],
           "> 10:1": [0, 4, 6, 10, 15, 20, 31, 45, 62, 82, 100]
       },
       30: {
           "< 3:1": [0, 4, 4, 5, 7, 10, 18, 28, 42, 58, 77, 100],
           "3:1 à 10:1": [0, 4, 4, 6, 9, 12, 20, 30, 44, 60, 80, 100],
           "> 10:1": [0, 4, 6, 10, 14, 18, 28, 40, 54, 71, 91, 100]
       },
       40: {
           "< 3:1": [0, 4, 4, 5, 6, 8, 14, 22, 32, 44, 59, 76, 94, 100],
           "3:1 à 10:1": [0, 4, 4, 6, 8, 10, 16, 24, 34, 47, 61, 78, 97, 100],
           "> 10:1": [0, 4, 5, 8, 12, 15, 23, 33, 44, 57, 72, 89, 100]
       },
       50: {
           "< 3:1": [0, 4, 4, 5, 6, 7, 12, 18, 26, 36, 48, 61, 76, 93, 100],
           "3:1 à 10:1": [0, 4, 4, 5, 7, 9, 14, 20, 29, 38, 50, 63, 79, 95, 100],
           "> 10:1": [0, 4, 5, 8, 11, 14, 21, 29, 38, 48, 61, 74, 90, 100]
       },
       60: {
           "< 3:1": [0, 4, 4, 4, 5, 7, 11, 16, 23, 31, 40, 52, 64, 78, 94, 100],
           "3:1 à 10:1": [0, 4, 4, 5, 6, 8, 12, 18, 25, 33, 43, 54, 66, 81, 96, 100],
           "> 10:1": [0, 4, 5, 7, 10, 13, 19, 26, 34, 43, 53, 64, 77, 92, 100]
       },
       80: {
           "< 3:1": [0, 4, 4, 4, 5, 6, 9, 13, 18, 24, 31, 40, 49, 60, 71, 84, 98, 100],
           "3:1 à 10:1": [0, 4, 4, 5, 6, 7, 10, 15, 20, 26, 33, 42, 51, 62, 74, 86, 100],
           "> 10:1": [0, 4, 5, 6, 9, 11, 16, 22, 28, 35, 43, 52, 62, 73, 85, 98, 100]
       },
       100: {
           "< 3:1": [0, 4, 4, 4, 5, 5, 8, 11, 15, 20, 26, 32, 40, 48, 58, 68, 79, 100],
           "3:1 à 10:1": [0, 4, 4, 4, 5, 6, 9, 13, 17, 22, 28, 35, 42, 51, 60, 70, 81, 100],
           "> 10:1": [0, 4, 4, 6, 8, 10, 14, 19, 25, 31, 37, 44, 52, 61, 71, 81, 92, 100]
       },
       150: {
           "< 3:1": [0, 4, 4, 4, 4, 5, 6, 8, 11, 14, 18, 23, 28, 33, 40, 46, 54, 70, 89, 100],
           "3:1 à 10:1": [0, 4, 4, 4, 5, 6, 8, 10, 13, 16, 20, 25, 30, 36, 42, 49, 56, 73, 92, 100],
           "> 10:1": [0, 4, 4, 5, 7, 8, 12, 16, 20, 24, 29, 34, 39, 46, 52, 59, 67, 84, 100]
       },
       250: {
           "< 3:1": [0, 4, 4, 4, 4, 4, 5, 7, 8, 10, 12, 15, 18, 22, 25, 29, 34, 44, 55, 68, 100],
           "3:1 à 10:1": [0, 4, 4, 4, 4, 5, 6, 8, 10, 12, 14, 17, 20, 24, 27, 32, 36, 46, 57, 70, 100],
         "> 10:1": [0, 4, 4, 5, 6, 7, 9, 12, 15, 18, 21, 25, 28, 32, 37, 41, 46, 56, 68, 81, 100]
       },
       350: {
           "< 3:1": [0, 4, 4, 4, 4, 4, 5, 6, 7, 8, 10, 12, 14, 16, 19, 22, 25, 32, 40, 49, 77, 100],
           "3:1 à 10:1": [0, 4, 4, 4, 4, 4, 5, 7, 8, 10, 12, 14, 16, 18, 21, 24, 27, 34, 43, 52, 79, 100],
           "> 10:1": [0, 4, 4, 4, 5, 6, 8, 10, 13, 15, 18, 21, 23, 26, 30, 33, 36, 44, 53, 62, 90, 100]
       },
       500: {
           "< 3:1": [0, 4, 4, 4, 4, 4, 4, 5, 6, 7, 8, 9, 11, 13, 14, 16, 19, 24, 29, 36, 55, 78, 100],
           "3:1 à 10:1": [0, 4, 4, 4, 4, 4, 5, 6, 7, 8, 9, 11, 13, 14, 16, 18, 21, 26, 31, 38, 57, 80, 100],
           "> 10:1": [0, 4, 4, 4, 5, 5, 7, 9, 11, 13, 15, 17, 19, 21, 24, 26, 29, 35, 41, 48, 68, 92, 100]
       },
       1000: {
           "< 3:1": [0, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 7, 8, 9, 10, 11, 14, 16, 20, 29, 41, 55, 71, 89, 100],
           "3:1 à 10:1": [0, 4, 4, 4, 4, 4, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 18, 22, 31, 43, 57, 73, 91, 100],
           "> 10:1": [0, 4, 4, 4, 4, 5, 6, 7, 8, 9, 11, 12, 13, 15, 16, 18, 20, 23, 26, 30, 41, 53, 68, 84, 100]
       },
       2000: {
           "< 3:1": [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 6, 6, 7, 7, 9, 10, 12, 16, 22, 29, 37, 46, 56, 68, 80, 94, 100],
           "3:1 à 10:1": [0, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 6, 6, 7, 7, 8, 9, 10, 12, 13, 18, 24, 31, 39, 49, 59, 70, 83, 96, 100],
           "> 10:1": [0, 4, 4, 4, 4, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 18, 20, 26, 33, 41, 50, 59, 70, 81, 94, 100]
       }
   };
   
   // Tableau 3.2.3.1.-D - Bâtiment protégé par gicleurs - Usages des groupes A, B, C, D et F3
   const tableauAvecGicleursGroupesABCDF3 = {
       10: [0, 16, 24, 42, 66, 100],
       15: [0, 16, 20, 34, 50, 74, 100],
       20: [0, 16, 20, 30, 42, 60, 100],
       25: [0, 16, 18, 26, 38, 52, 90, 100],
       30: [0, 14, 18, 24, 34, 46, 78, 100],
       40: [0, 14, 16, 22, 30, 40, 64, 96, 100],
       50: [0, 14, 16, 20, 28, 36, 56, 82, 100],
       60: [0, 14, 16, 20, 26, 32, 50, 72, 98, 100],
       80: [0, 14, 16, 18, 22, 28, 42, 58, 80, 100],
       100: [0, 14, 16, 18, 22, 26, 36, 50, 68, 88, 100],
       150: [0, 14, 14, 16, 20, 22, 30, 40, 52, 66, 82, 100]
   };
   
   // Tableau 3.2.3.1.-E - Bâtiment protégé par gicleurs - Usages des groupes E, F1 et F2
   const tableauAvecGicleursGroupesEF1F2 = {
       10: [0, 8, 12, 20, 34, 50, 96, 100],
       15: [0, 8, 10, 16, 26, 36, 68, 100],
       20: [0, 8, 10, 14, 22, 30, 54, 86, 100],
       25: [0, 8, 10, 14, 18, 26, 44, 70, 100],
       30: [0, 8, 8, 12, 18, 24, 40, 60, 88, 100],
       40: [0, 8, 8, 12, 16, 20, 32, 48, 68, 94, 100],
       50: [0, 8, 8, 10, 14, 18, 28, 40, 58, 76, 100],
       60: [0, 8, 8, 10, 12, 16, 24, 36, 50, 66, 86, 100],
       80: [0, 8, 8, 10, 12, 14, 20, 30, 40, 52, 66, 84, 100],
       100: [0, 8, 8, 8, 10, 12, 18, 26, 34, 44, 56, 70, 84, 100],
       150: [0, 8, 8, 8, 10, 12, 16, 20, 26, 32, 40, 50, 60, 72, 84, 98, 100],
       200: [0, 8, 8, 8, 8, 10, 14, 18, 22, 28, 34, 42,50, 60, 68, 80, 92, 100]
   };

   const limitingDistancesNoSprinklers = [0, 1.2, 1.5, 2.0, 2.5, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 18, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70];
   const limitingDistancesWithSprinklersABCDF3 = [0, 1.2, 1.5, 2.0, 2.5, 3, 4, 5, 6, 7, 8, 9];
   const limitingDistancesWithSprinklersEF1F2 = [0, 1.2, 1.5, 2.0, 2.5, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
   const facadeSurfaces = [10, 15, 20, 25, 30, 40, 50, 60, 80, 100, 150, 250, 350, 500, 1000, 2000];
   const facadeSurfacesWithSprinklersABCDF3 = [10, 15, 20, 25, 30, 40, 50, 60, 80, 100, 150, 250, 350, 500, 1000, 2000];
   const facadeSurfacesWithSprinklersEF1F2 = [10, 15, 20, 25, 30, 40, 50, 60, 80, 100, 150, 200];

// Données du Tableau 9.10.14.4-A
const tableau91014 = {
    "habitation": {
        surfaces: {
            30: [0, 7, 9, 12, 39, 88, 100, 100, 100, 100, 100, 100, 100],
            40: [0, 7, 8, 11, 32, 69, 100, 100, 100, 100, 100, 100, 100],
            50: [0, 7, 8, 10, 28, 57, 100, 100, 100, 100, 100, 100, 100],
            100: [0, 7, 8, 9, 18, 34, 56, 84, 100, 100, 100, 100, 100],
            ">100": [0, 7, 7, 8, 12, 19, 28, 40, 55, 92, 100, 100, 100]
        },
        distances: [0, 1.2, 1.5, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 16.0, 20.0, 25.0, 30.0]
    },
    "commercial": {
        surfaces: {
            30: [0, 4, 4, 6, 20, 44, 80, 100, 100, 100, 100, 100, 100],
            40: [0, 4, 4, 6, 16, 34, 61, 97, 100, 100, 100, 100, 100],
            50: [0, 4, 4, 5, 14, 29, 50, 79, 100, 100, 100, 100, 100],
            100: [0, 4, 4, 4, 9, 17, 28, 42, 60, 100, 100, 100, 100],
            ">100": [0, 4, 4, 4, 6, 10, 14, 20, 27, 46, 70, 100, 100]
        },
        distances: [0, 1.2, 1.5, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 16.0, 20.0, 25.0, 30.0]
    }
};

// Données du Tableau 9.10.15.4
const tableau91015 = {
    surfaces: {
        30: [0, 7, 9, 12, 39, 88, 100, 100, 100, 100, 100],
        40: [0, 7, 8, 11, 32, 69, 100, 100, 100, 100, 100],
        50: [0, 7, 8, 10, 28, 57, 100, 100, 100, 100, 100],
        100: [0, 7, 8, 9, 18, 34, 56, 84, 100, 100, 100],
        ">100": [0, 7, 7, 8, 12, 19, 28, 40, 55, 92, 100]
    },
    distances: [0, 1.2, 1.5, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 16.0, 20.0]
};

   // Fonction pour calculer les dimensions automatiquement
function updateDimensions(event) {
    // Identifier quel champ vient d'être modifié
    const changedField = event.target.id;
    
    const surfaceField = document.getElementById('surface_cnb');
    const lengthField = document.getElementById('length_cnb');
    const heightField = document.getElementById('height_cnb');
    
    const surface = parseFloat(surfaceField.value);
    const length = parseFloat(lengthField.value);
    const height = parseFloat(heightField.value);
    
    // Ne pas faire de calcul si le champ actif est vidé
    if (event.target.value === "") {
        return;
    }
    
    // Ajuster selon le champ qui a été modifié
    if (changedField === 'surface_cnb') {
        // Si la surface est modifiée et que la longueur ou la hauteur existe, mettre à jour l'autre dimension
        if (!isNaN(length)) {
            // Calculer la hauteur
            const calculatedHeight = surface / length;
            heightField.value = calculatedHeight.toFixed(2).replace('.', ',');
        } else if (!isNaN(height)) {
            // Calculer la longueur
            const calculatedLength = surface / height;
            lengthField.value = calculatedLength.toFixed(2).replace('.', ',');
        }
    } else if (changedField === 'length_cnb') {
        // Si la longueur est modifiée
        if (!isNaN(surface)) {
            // Calculer la hauteur basée sur la surface
            const calculatedHeight = surface / length;
            heightField.value = calculatedHeight.toFixed(2).replace('.', ',');
        } else if (!isNaN(height)) {
            // Calculer la surface
            const calculatedSurface = length * height;
            surfaceField.value = calculatedSurface.toFixed(2).replace('.', ',');
        }
    } else if (changedField === 'height_cnb') {
        // Si la hauteur est modifiée
        if (!isNaN(surface)) {
            // Calculer la longueur basée sur la surface
            const calculatedLength = surface / height;
            lengthField.value = calculatedLength.toFixed(2).replace('.', ',');
        } else if (!isNaN(length)) {
            // Calculer la surface
            const calculatedSurface = length * height;
            surfaceField.value = calculatedSurface.toFixed(2).replace('.', ',');
        }
    }
}
// Afficher/masquer les options supplémentaires
document.addEventListener('DOMContentLoaded', function() {
    // Gestionnaires d'événements pour les checkboxes de vérification d'espacement
    document.getElementById('check_spacing_cnb').addEventListener('change', function() {
        document.getElementById('spacing_options_cnb').style.display = this.checked ? 'block' : 'none';
    });
                    
    document.getElementById('check_spacing_91014').addEventListener('change', function() {
        document.getElementById('spacing_options_91014').style.display = this.checked ? 'block' : 'none';
    });
    
    document.getElementById('check_spacing_91015').addEventListener('change', function() {
            document.getElementById('spacing_options_91015').style.display = this.checked ? 'block' : 'none';
        });
        
    // Gestionnaires d'événements pour les checkboxes de vérification des soffites
    document.getElementById('check_soffit_cnb').addEventListener('change', function() {
        document.getElementById('soffit_options_cnb').style.display = this.checked ? 'block' : 'none';
    });
        
    document.getElementById('check_soffit_91014').addEventListener('change', function() {
        document.getElementById('soffit_options_91014').style.display = this.checked ? 'block' : 'none';
    });
        
    document.getElementById('check_soffit_91015').addEventListener('change', function() {
        document.getElementById('soffit_options_91015').style.display = this.checked ? 'block' : 'none';
    });
        
    // Ajouter des écouteurs pour l'onglet CNB
    const cnbInputs = document.querySelectorAll('#cnb input[type="number"]');
    cnbInputs.forEach(input => {
        input.addEventListener('keypress', function(event) {
            handleEnterKey(event, calculateCNB);
        });
    });

    // Ajouter des écouteurs pour l'onglet 9.10.14
    const inputs91014 = document.querySelectorAll('#method91014 input[type="number"]');
    inputs91014.forEach(input => {
        input.addEventListener('keypress', function(event) {
            handleEnterKey(event, calculate91014);
        });
    });

    // Ajouter des écouteurs pour l'onglet 9.10.15
    const inputs91015 = document.querySelectorAll('#method91015 input[type="number"]');
    inputs91015.forEach(input => {
        input.addEventListener('keypress', function(event) {
            handleEnterKey(event, calculate91015);
        });
    });

    // Écouteurs d'événements pour le calcul automatique des dimensions
    document.getElementById('surface_cnb').addEventListener('input', updateDimensions);
    document.getElementById('length_cnb').addEventListener('input', updateDimensions);
    document.getElementById('height_cnb').addEventListener('input', updateDimensions);
});

// Fonction pour déterminer la catégorie du rapport L/H
function determinerRapportLH(longueur, hauteur) {
    const rapportLH = longueur / hauteur;
    const rapportHL = hauteur / longueur;
    const maxRapport = Math.max(rapportLH, rapportHL);
    
    if (maxRapport < 3) return "< 3:1";
    if (maxRapport <= 10) return "3:1 à 10:1";
    return "> 10:1";
}

// Fonction pour trouver les valeurs encadrantes dans un tableau - MODIFIÉE pour extrapolation
function trouverValeurEncadrantes(valeur, tableau) {
    // Cas particulier: valeur exactement 0
    if (valeur === 0) {
        return { inferieure: 0, superieure: 0, extrapolation: false };
    }
    
    // Cas où la valeur est inférieure au premier élément non-nul
    let premierElementNonNul = tableau.find(e => e > 0);
    if (valeur > 0 && valeur < premierElementNonNul) {
        return { 
            inferieure: 0, 
            superieure: premierElementNonNul, 
            extrapolation: true,
            valeurExacte: valeur
        };
    }
    
    // Si la valeur est inférieure au premier élément (et non nulle)
    if (valeur <= tableau[0]) {
        return { inferieure: tableau[0], superieure: tableau[0], extrapolation: false };
    }
    
    // Si la valeur est supérieure au dernier élément
    if (valeur >= tableau[tableau.length - 1]) {
        return { inferieure: tableau[tableau.length - 1], superieure: tableau[tableau.length - 1], extrapolation: false };
    }
    
    // Rechercher les bornes encadrantes
    for (let i = 0; i < tableau.length - 1; i++) {
        if (valeur >= tableau[i] && valeur <= tableau[i + 1]) {
            return { inferieure: tableau[i], superieure: tableau[i + 1], extrapolation: false };
        }
    }
    
    // En cas d'échec (ne devrait jamais arriver si les vérifications ci-dessus sont correctes)
    return { inferieure: tableau[0], superieure: tableau[1], extrapolation: false };
}

// Fonction pour l'extrapolation des valeurs entre 0 et la première valeur non-nulle
function extrapolerPourcentage(pourcentage0, pourcentageMin, distanceMin, distanceExacte) {
    // Avec distanceExacte entre 0 et distanceMin
    // Pourcentage à 0 est généralement 0 dans les tableaux
    const pente = (pourcentageMin - pourcentage0) / distanceMin;
    const pourcentageExtrapole = pourcentage0 + (pente * distanceExacte);
    return Math.max(0, pourcentageExtrapole); // Ne jamais retourner un pourcentage négatif
}

// Fonction pour l'extrapolation des valeurs pour des surfaces inférieures au minimum du tableau
function extrapolerPourcentageSurface(pourcentageSurfaceMin, pourcentageSurfaceSupMin, surfaceMin, surfaceExacte) {
    if (surfaceExacte >= surfaceMin) return pourcentageSurfaceMin;
    
    // Tendance observée: plus la surface est petite, plus le pourcentage permis est élevé
    // On utilise une extrapolation linéaire inverse
    const ratio = surfaceMin / surfaceExacte;
    const facteur = Math.sqrt(ratio); // Facteur modérateur pour éviter une croissance trop rapide
    
    // En se basant sur la différence entre les pourcentages aux deux premières surfaces du tableau
    const tendance = (pourcentageSurfaceMin - pourcentageSurfaceSupMin) * (facteur - 1);
    return Math.min(100, pourcentageSurfaceMin + tendance); // Limitée à 100%
}

// Nouvelle fonction pour extrapoler entre la distance, surface existante et petite surface
function extrapolerPetiteSurfaceDLExistante(distanceLimitative, surfaceFacade, tableauUtilise, distancesUtilisees, surfacesUtilisees, rapportLH, avecGicleurs) {
    // Étape 1: Interpolation selon la 1ère FDR disponible
    // Trouver les bornes d'encadrement pour la distance limitative
    const distancesEncadrantes = trouverValeurEncadrantes(distanceLimitative, distancesUtilisees);
    const distanceInferieure = distancesEncadrantes.inferieure;
    const distanceSuperieure = distancesEncadrantes.superieure;
    const distanceInferieureIndex = distancesUtilisees.indexOf(distanceInferieure);
    const distanceSuperieureIndex = distancesUtilisees.indexOf(distanceSuperieure);
    
    let pourcentageDL1_FDR1, pourcentageDL2_FDR1;
    if (!avecGicleurs) {
        pourcentageDL1_FDR1 = tableauUtilise[surfacesUtilisees[0]][rapportLH][distanceInferieureIndex];
        pourcentageDL2_FDR1 = tableauUtilise[surfacesUtilisees[0]][rapportLH][distanceSuperieureIndex];
    } else {
        pourcentageDL1_FDR1 = tableauUtilise[surfacesUtilisees[0]][distanceInferieureIndex];
        pourcentageDL2_FDR1 = tableauUtilise[surfacesUtilisees[0]][distanceSuperieureIndex];
    }
    
    // Interpolation pour la 1ère FDR à la distance donnée
    const pourcentageFDR1 = pourcentageDL1_FDR1 + 
        ((distanceLimitative - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
        (pourcentageDL2_FDR1 - pourcentageDL1_FDR1);
    
    // Étape 2: Interpolation selon la 2ème FDR disponible
    let pourcentageDL1_FDR2, pourcentageDL2_FDR2;
    if (!avecGicleurs) {
        pourcentageDL1_FDR2 = tableauUtilise[surfacesUtilisees[1]][rapportLH][distanceInferieureIndex];
        pourcentageDL2_FDR2 = tableauUtilise[surfacesUtilisees[1]][rapportLH][distanceSuperieureIndex];
    } else {
        pourcentageDL1_FDR2 = tableauUtilise[surfacesUtilisees[1]][distanceInferieureIndex];
        pourcentageDL2_FDR2 = tableauUtilise[surfacesUtilisees[1]][distanceSuperieureIndex];
    }
    
    // Interpolation pour la 2ème FDR à la distance donnée
    const pourcentageFDR2 = pourcentageDL1_FDR2 + 
        ((distanceLimitative - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
        (pourcentageDL2_FDR2 - pourcentageDL1_FDR2);
    
    // Étape 3: Extrapolation pour la surface réelle
    const pourcentageFinal = pourcentageFDR2 + 
        ((surfaceFacade - surfacesUtilisees[1]) / (surfacesUtilisees[0] - surfacesUtilisees[1])) * 
        (pourcentageFDR1 - pourcentageFDR2);
    
    return Math.max(0, Math.min(100, pourcentageFinal));
}

// Nouvelle fonction pour extrapoler avec petite distance limitative et surface existante
function extrapolerPetiteDLSurfaceExistante(distanceLimitative, surfaceFacade, tableauUtilise, distancesUtilisees, surfacesUtilisees, rapportLH, avecGicleurs) {
    // Étape 1: Interpolation selon la surface pour DL=0
    const pourcentage0 = 0; // À DL=0, le pourcentage est toujours 0
    
    // Étape 2: Interpolation selon la surface pour première DL non-nulle
    const premiereDLNonNulle = distancesUtilisees.find(d => d > 0);
    const indexPremiereDL = distancesUtilisees.indexOf(premiereDLNonNulle);
    
    // Trouver les surfaces encadrantes
    const surfacesEncadrantes = trouverValeurEncadrantes(surfaceFacade, surfacesUtilisees);
    const surfaceInferieure = surfacesEncadrantes.inferieure;
    const surfaceSuperieure = surfacesEncadrantes.superieure;
    
    let pourcentageDLMin_SurfInf, pourcentageDLMin_SurfSup;
    if (!avecGicleurs) {
        pourcentageDLMin_SurfInf = tableauUtilise[surfaceInferieure][rapportLH][indexPremiereDL];
        pourcentageDLMin_SurfSup = tableauUtilise[surfaceSuperieure][rapportLH][indexPremiereDL];
    } else {
        pourcentageDLMin_SurfInf = tableauUtilise[surfaceInferieure][indexPremiereDL];
        pourcentageDLMin_SurfSup = tableauUtilise[surfaceSuperieure][indexPremiereDL];
    }
    
    // Interpolation pour la surface réelle à la première DL non-nulle
    const pourcentagePremiereDL = pourcentageDLMin_SurfSup + 
        ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
        (pourcentageDLMin_SurfInf - pourcentageDLMin_SurfSup);
    
    // Étape 3: Extrapolation entre DL=0 et première DL non-nulle
    const pente = (pourcentagePremiereDL - pourcentage0) / premiereDLNonNulle;
    const pourcentageFinal = pourcentage0 + (pente * distanceLimitative);
    
    return Math.max(0, Math.min(100, pourcentageFinal));
}

// Nouvelle fonction pour extrapoler avec petite distance limitative et petite surface
function extrapolerPetiteDLPetiteSurface(distanceLimitative, surfaceFacade, tableauUtilise, distancesUtilisees, surfacesUtilisees, rapportLH, avecGicleurs) {
    // Étape 1: Interpolation selon la 1ère FDR disponible à DL=0
    const pourcentage0_FDR1 = 0; // À DL=0, le pourcentage est toujours 0
    
    // Étape 2: Interpolation selon la 1ère FDR disponible à première DL non-nulle
    const premiereDLNonNulle = distancesUtilisees.find(d => d > 0);
    const indexPremiereDL = distancesUtilisees.indexOf(premiereDLNonNulle);
    
    let pourcentageDLMin_FDR1;
    if (!avecGicleurs) {
        pourcentageDLMin_FDR1 = tableauUtilise[surfacesUtilisees[0]][rapportLH][indexPremiereDL];
    } else {
        pourcentageDLMin_FDR1 = tableauUtilise[surfacesUtilisees[0]][indexPremiereDL];
    }
    
    // Extrapolation pour la 1ère FDR à la distance donnée
    const pente1 = (pourcentageDLMin_FDR1 - pourcentage0_FDR1) / premiereDLNonNulle;
    const pourcentageFDR1 = pourcentage0_FDR1 + (pente1 * distanceLimitative);
    
    // Étape 3: Même chose pour la 2ème FDR disponible
    const pourcentage0_FDR2 = 0;
    
    let pourcentageDLMin_FDR2;
    if (!avecGicleurs) {
        pourcentageDLMin_FDR2 = tableauUtilise[surfacesUtilisees[1]][rapportLH][indexPremiereDL];
    } else {
        pourcentageDLMin_FDR2 = tableauUtilise[surfacesUtilisees[1]][indexPremiereDL];
    }
    
    // Extrapolation pour la 2ème FDR à la distance donnée
    const pente2 = (pourcentageDLMin_FDR2 - pourcentage0_FDR2) / premiereDLNonNulle;
    const pourcentageFDR2 = pourcentage0_FDR2 + (pente2 * distanceLimitative);
    
    // Étape 4: Extrapolation pour la surface réelle
    const pourcentageFinal = pourcentageFDR2 + 
        ((surfaceFacade - surfacesUtilisees[1]) / (surfacesUtilisees[0] - surfacesUtilisees[1])) * 
        (pourcentageFDR1 - pourcentageFDR2);
    
    return Math.max(0, Math.min(100, pourcentageFinal));
}

// Fonction d'interpolation principale MODIFIÉE avec extrapolation
function interpolationCNB(usage, distanceLimitative, surfaceFacade, rapportLH, avecGicleurs) {
    // Déterminer les tableaux à utiliser en fonction de l'usage et de la présence de gicleurs
    let tableauUtilise, distancesUtilisees, surfacesUtilisees;
    
    if (avecGicleurs) {
        if (usage === "groupes_A_B3_C_D_F3") {
            tableauUtilise = tableauAvecGicleursGroupesABCDF3;
            distancesUtilisees = limitingDistancesWithSprinklersABCDF3;
            surfacesUtilisees = facadeSurfacesWithSprinklersABCDF3;
        } else { // groupes_E_F1_F2
            tableauUtilise = tableauAvecGicleursGroupesEF1F2;
            distancesUtilisees = limitingDistancesWithSprinklersEF1F2;
            surfacesUtilisees = facadeSurfacesWithSprinklersEF1F2;
        }
    } else {
        distancesUtilisees = limitingDistancesNoSprinklers;
        surfacesUtilisees = facadeSurfaces;
        if (usage === "groupes_A_B3_C_D_F3") {
            tableauUtilise = tableauGroupesAB3CDF3;
        } else { // groupes_E_F1_F2
            tableauUtilise = tableauGroupesEF1F2;
        }
    }
    
    // Vérifier si la distance limitative dépasse la plage du tableau
    if (distanceLimitative > distancesUtilisees[distancesUtilisees.length - 1]) {
        return 100; // 100% de baies non protégées autorisées
    }
    
    // Vérifier le cas particulier: petite surface et distance limitative valide
    const premiereDLNonNulle = distancesUtilisees.find(d => d > 0);
    if (surfaceFacade < surfacesUtilisees[0] && distanceLimitative >= premiereDLNonNulle) {
        return extrapolerPetiteSurfaceDLExistante(
            distanceLimitative,
            surfaceFacade,
            tableauUtilise,
            distancesUtilisees,
            surfacesUtilisees,
            rapportLH,
            avecGicleurs
        );
    }
    
    // Vérifier le cas particulier: petite distance limitative et surface valide
    if (distanceLimitative > 0 && distanceLimitative < premiereDLNonNulle && surfaceFacade >= surfacesUtilisees[0]) {
        return extrapolerPetiteDLSurfaceExistante(
            distanceLimitative,
            surfaceFacade,
            tableauUtilise,
            distancesUtilisees,
            surfacesUtilisees,
            rapportLH,
            avecGicleurs
        );
    }
    
    // Vérifier le cas particulier: petite distance limitative et petite surface
    if (distanceLimitative > 0 && distanceLimitative < premiereDLNonNulle && surfaceFacade < surfacesUtilisees[0]) {
        return extrapolerPetiteDLPetiteSurface(
            distanceLimitative,
            surfaceFacade,
            tableauUtilise,
            distancesUtilisees,
            surfacesUtilisees,
            rapportLH,
            avecGicleurs
        );
    }
    
    // ÉTAPE 0: Trouver les bornes d'encadrement pour la distance limitative
    const distancesEncadrantes = trouverValeurEncadrantes(distanceLimitative, distancesUtilisees);
    const distanceInferieure = distancesEncadrantes.inferieure;
    const distanceSuperieure = distancesEncadrantes.superieure;
    const distanceInferieureIndex = distancesUtilisees.indexOf(distanceInferieure);
    const distanceSuperieureIndex = distancesUtilisees.indexOf(distanceSuperieure);
    const extrapolationDistance = distancesEncadrantes.extrapolation;
    const distanceExacte = distancesEncadrantes.valeurExacte;
    
    // Trouver les surfaces encadrantes pour la façade de rayonnement
    const surfaceFacadeMin = Math.min(surfaceFacade, surfacesUtilisees[0]); // Pour l'extrapolation
    const surfacesEncadrantes = trouverValeurEncadrantes(surfaceFacade, surfacesUtilisees);
    const surfaceInferieure = surfacesEncadrantes.inferieure;
    const surfaceSuperieure = surfacesEncadrantes.superieure;
    
    // Cas spécial: extrapolation pour petites surfaces (< 10m²)
    const extrapolationSurface = surfaceFacade < surfacesUtilisees[0];
    
    // Cas spécial: extrapolation pour distance limitative entre 0 et 1.2m
    if (extrapolationDistance) {
        let pourcentageDistance0, pourcentageDistanceMin;
        
        if (extrapolationSurface) {
            // Double extrapolation (distance et surface)
            // D'abord extrapoler pour la surface minimale, puis pour la surface réelle
            
            // Pour distance = 0
            pourcentageDistance0 = 0; // Toujours 0% quand DL=0
            
            // Pour distance = min (1.2m)
            if (!avecGicleurs) {
                const pourcentageSurfMin = tableauUtilise[surfacesUtilisees[0]][rapportLH][distanceSuperieureIndex];
                const pourcentageSurfSupMin = tableauUtilise[surfacesUtilisees[1]][rapportLH][distanceSuperieureIndex];
                
                // Extrapolation pour surface plus petite avec distance min
                pourcentageDistanceMin = extrapolerPourcentageSurface(
                    pourcentageSurfMin, 
                    pourcentageSurfSupMin, 
                    surfacesUtilisees[0], 
                    surfaceFacade
                );
            } else {
                const pourcentageSurfMin = tableauUtilise[surfacesUtilisees[0]][distanceSuperieureIndex];
                const pourcentageSurfSupMin = tableauUtilise[surfacesUtilisees[1]][distanceSuperieureIndex];
                
                // Extrapolation pour surface plus petite avec distance min
                pourcentageDistanceMin = extrapolerPourcentageSurface(
                    pourcentageSurfMin, 
                    pourcentageSurfSupMin, 
                    surfacesUtilisees[0], 
                    surfaceFacade
                );
            }
        } else {
            // Extrapolation simple pour la distance uniquement
            pourcentageDistance0 = 0; // Toujours 0% quand DL=0
            
            if (!avecGicleurs) {
                pourcentageDistanceMin = tableauUtilise[surfaceInferieure][rapportLH][distanceSuperieureIndex];
            } else {
                pourcentageDistanceMin = tableauUtilise[surfaceInferieure][distanceSuperieureIndex];
            }
        }
        
        // Extrapolation entre 0 et la première distance non-nulle
        return extrapolerPourcentage(
            pourcentageDistance0, 
            pourcentageDistanceMin, 
            distanceSuperieure, 
            distanceExacte
        );
    }
    
    // Cas spécial: extrapolation pour petites surfaces (< 10m²)
    if (extrapolationSurface) {
        let pourcentageSurfaceMin, pourcentageSurfaceSupMin;
        
        if (!avecGicleurs) {
            pourcentageSurfaceMin = tableauUtilise[surfacesUtilisees[0]][rapportLH][distanceInferieureIndex];
            pourcentageSurfaceSupMin = tableauUtilise[surfacesUtilisees[1]][rapportLH][distanceInferieureIndex];
        } else {
            pourcentageSurfaceMin = tableauUtilise[surfacesUtilisees[0]][distanceInferieureIndex];
            pourcentageSurfaceSupMin = tableauUtilise[surfacesUtilisees[1]][distanceInferieureIndex];
        }
        
        return extrapolerPourcentageSurface(
            pourcentageSurfaceMin,
            pourcentageSurfaceSupMin,
            surfacesUtilisees[0],
            surfaceFacade
        );
    }
    
    // Si les distances sont identiques, pas besoin d'interpolation complexe
    if (distanceInferieure === distanceSuperieure) {
        return interpolationSurfaceUniquement(tableauUtilise, surfaceFacade, surfaceInferieure, 
               surfaceSuperieure, distanceInferieureIndex, rapportLH, avecGicleurs);
    }
    
    // Si les surfaces sont identiques, pas besoin d'interpolation complexe
    if (surfaceInferieure === surfaceSuperieure) {
        return interpolationDistanceUniquement(tableauUtilise, distanceLimitative, distanceInferieure, 
               distanceSuperieure, surfaceInferieure, distanceInferieureIndex, 
               distanceSuperieureIndex, rapportLH, avecGicleurs);
    }
    
    // ÉTAPE 1: Interpolation selon la DL inférieure - MODIFIÉE
    let pourcentageDistanceInferieure;
    
    if (!avecGicleurs) {
        const pourcentageSurfInfDistInf = tableauUtilise[surfaceInferieure][rapportLH][distanceInferieureIndex];
        const pourcentageSurfSupDistInf = tableauUtilise[surfaceSuperieure][rapportLH][distanceInferieureIndex];
        
        // Formule MODIFIÉE selon la méthodologie de référence
        pourcentageDistanceInferieure = pourcentageSurfSupDistInf + 
            ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistInf - pourcentageSurfSupDistInf);
    } else {
        const pourcentageSurfInfDistInf = tableauUtilise[surfaceInferieure][distanceInferieureIndex];
        const pourcentageSurfSupDistInf = tableauUtilise[surfaceSuperieure][distanceInferieureIndex];
        
        // Formule MODIFIÉE selon la méthodologie de référence
        pourcentageDistanceInferieure = pourcentageSurfSupDistInf + 
            ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistInf - pourcentageSurfSupDistInf);
    }
    
    // ÉTAPE 2: Interpolation selon la DL supérieure - MODIFIÉE
    let pourcentageDistanceSuperieure;
    
    if (!avecGicleurs) {
        const pourcentageSurfInfDistSup = tableauUtilise[surfaceInferieure][rapportLH][distanceSuperieureIndex];
        const pourcentageSurfSupDistSup = tableauUtilise[surfaceSuperieure][rapportLH][distanceSuperieureIndex];
        
        // Formule MODIFIÉE selon la méthodologie de référence
        pourcentageDistanceSuperieure = pourcentageSurfSupDistSup + 
            ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistSup - pourcentageSurfSupDistSup);
    } else {
        const pourcentageSurfInfDistSup = tableauUtilise[surfaceInferieure][distanceSuperieureIndex];
        const pourcentageSurfSupDistSup = tableauUtilise[surfaceSuperieure][distanceSuperieureIndex];
        
        // Formule MODIFIÉE selon la méthodologie de référence
        pourcentageDistanceSuperieure = pourcentageSurfSupDistSup + 
            ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistSup - pourcentageSurfSupDistSup);
    }
    
    // ÉTAPE 3: Interpolation finale entre les deux résultats d'interpolation précédents
    const pourcentageFinal = pourcentageDistanceInferieure + 
        ((distanceLimitative - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
        (pourcentageDistanceSuperieure - pourcentageDistanceInferieure);
    
    // Limiter le pourcentage final entre 0 et 100
    return Math.max(0, Math.min(100, pourcentageFinal));
}

// Fonction pour l'interpolation quand seule la surface varie (distance fixe)
function interpolationSurfaceUniquement(tableauUtilise, surfaceFacade, surfaceInferieure, 
                                      surfaceSuperieure, distanceIndex, rapportLH, avecGicleurs) {
    // Cas spécial: extrapolation pour petites surfaces (< 10m²)
    const extrapolationSurface = surfaceFacade < surfaceInferieure && surfaceInferieure === Math.min(...facadeSurfaces);
    
    if (extrapolationSurface) {
        let pourcentageSurfaceMin, pourcentageSurfaceSupMin;
        
        if (!avecGicleurs) {
            pourcentageSurfaceMin = tableauUtilise[surfaceInferieure][rapportLH][distanceIndex];
            pourcentageSurfaceSupMin = tableauUtilise[Math.min(...facadeSurfaces.filter(s => s > surfaceInferieure))][rapportLH][distanceIndex];
        } else {
            pourcentageSurfaceMin = tableauUtilise[surfaceInferieure][distanceIndex];
            pourcentageSurfaceSupMin = tableauUtilise[Math.min(...facadeSurfaces.filter(s => s > surfaceInferieure))][distanceIndex];
        }
        
        return extrapolerPourcentageSurface(
            pourcentageSurfaceMin,
            pourcentageSurfaceSupMin,
            surfaceInferieure,
            surfaceFacade
        );
    }
    
    let pourcentageSurfInf, pourcentageSurfSup;
    
    if (!avecGicleurs) {
        pourcentageSurfInf = tableauUtilise[surfaceInferieure][rapportLH][distanceIndex];
        pourcentageSurfSup = tableauUtilise[surfaceSuperieure][rapportLH][distanceIndex];
    } else {
        pourcentageSurfInf = tableauUtilise[surfaceInferieure][distanceIndex];
        pourcentageSurfSup = tableauUtilise[surfaceSuperieure][distanceIndex];
    }
    
    // Si les surfaces sont identiques, retourner directement la valeur
    if (surfaceInferieure === surfaceSuperieure) {
        return pourcentageSurfInf;
    }
    
    // Interpolation linéaire entre les surfaces - CORRIGÉE selon méthodologie
    return pourcentageSurfSup + 
        ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
        (pourcentageSurfInf - pourcentageSurfSup);
}

// Fonction pour l'interpolation quand seule la distance varie (surface unique)
function interpolationDistanceUniquement(tableauUtilise, distanceLimitative, distanceInferieure, 
                                       distanceSuperieure, surface, distanceInferieureIndex, 
                                       distanceSuperieureIndex, rapportLH, avecGicleurs) {
    // Cas spécial: extrapolation pour distance limitative entre 0 et 1.2m
    const extrapolationDistance = distanceLimitative > 0 && distanceLimitative < distanceSuperieure && distanceInferieure === 0;
    
    if (extrapolationDistance) {
        let pourcentageDistance0 = 0; // Toujours 0% quand DL=0
        let pourcentageDistanceMin;
        
        if (!avecGicleurs) {
            pourcentageDistanceMin = tableauUtilise[surface][rapportLH][distanceSuperieureIndex];
        } else {
            pourcentageDistanceMin = tableauUtilise[surface][distanceSuperieureIndex];
        }
        
        // Extrapolation entre 0 et la première distance non-nulle
        return extrapolerPourcentage(
            pourcentageDistance0,
            pourcentageDistanceMin,
            distanceSuperieure,
            distanceLimitative
        );
    }
    
    let pourcentageDistInf, pourcentageDistSup;
    
    if (!avecGicleurs) {
        pourcentageDistInf = tableauUtilise[surface][rapportLH][distanceInferieureIndex];
        pourcentageDistSup = tableauUtilise[surface][rapportLH][distanceSuperieureIndex];
    } else {
        pourcentageDistInf = tableauUtilise[surface][distanceInferieureIndex];
        pourcentageDistSup = tableauUtilise[surface][distanceSuperieureIndex];
    }
    
    // Si les distances sont identiques, retourner directement la valeur
    if (distanceInferieure === distanceSuperieure) {
        return pourcentageDistInf;
    }
    
    // Interpolation linéaire entre les distances - CORRIGÉE selon méthodologie
    return pourcentageDistInf + 
        ((distanceLimitative - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
        (pourcentageDistSup - pourcentageDistInf);
}

// Fonction pour le calcul selon 9.10.14.4 ou 9.10.15.4 - MODIFIÉE avec extrapolation
function calculerPourcentage910x(tableau, distanceLimitative, surfaceFacade, avecGicleurs, avecMajoration) {
    const distances = tableau.distances;
    
    // Vérifier si la distance limitative est supérieure à la plage du tableau
    if (distanceLimitative > distances[distances.length - 1]) {
        return 100; // 100% de baies non protégées autorisées
    }
    
    // Déterminer les surfaces disponibles dans le tableau
    const surfacesDisponibles = Object.keys(tableau.surfaces).filter(s => s !== ">100").map(Number);
    
    // Cas particulier 1: petite surface et distance limitative existante
    const premiereDLNonNulle = distances.find(d => d > 0);
    if (surfaceFacade < surfacesDisponibles[0] && distanceLimitative >= premiereDLNonNulle) {
        // Étape 1: Interpolation pour la 1ère surface disponible
        const distancesEncadrantes = trouverValeurEncadrantes(distanceLimitative, distances);
        const distanceInferieure = distancesEncadrantes.inferieure;
        const distanceSuperieure = distancesEncadrantes.superieure;
        const distanceInferieureIndex = distances.indexOf(distanceInferieure);
        const distanceSuperieureIndex = distances.indexOf(distanceSuperieure);
        
        // Interpolation pour la 1ère surface
        const pourcentageDL1_FDR1 = tableau.surfaces[surfacesDisponibles[0].toString()][distanceInferieureIndex];
        const pourcentageDL2_FDR1 = tableau.surfaces[surfacesDisponibles[0].toString()][distanceSuperieureIndex];
        
        const pourcentageFDR1 = pourcentageDL1_FDR1 + 
            ((distanceLimitative - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
            (pourcentageDL2_FDR1 - pourcentageDL1_FDR1);
        
        // Étape 2: Interpolation pour la 2ème surface disponible
        const pourcentageDL1_FDR2 = tableau.surfaces[surfacesDisponibles[1].toString()][distanceInferieureIndex];
        const pourcentageDL2_FDR2 = tableau.surfaces[surfacesDisponibles[1].toString()][distanceSuperieureIndex];
        
        const pourcentageFDR2 = pourcentageDL1_FDR2 + 
            ((distanceLimitative - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
            (pourcentageDL2_FDR2 - pourcentageDL1_FDR2);
        
        // Étape 3: Extrapolation pour la surface réelle
        let pourcentageFinal = pourcentageFDR2 + 
            ((surfaceFacade - surfacesDisponibles[1]) / (surfacesDisponibles[0] - surfacesDisponibles[1])) * 
            (pourcentageFDR1 - pourcentageFDR2);
        
        // Appliquer la majoration si nécessaire
        if (avecMajoration || avecGicleurs) {
            pourcentageFinal = Math.min(100, pourcentageFinal * 2);
        }
        
        return Math.max(0, Math.min(100, pourcentageFinal));
    }
    
    // Cas particulier 2: petite distance limitative et surface existante
    if (distanceLimitative > 0 && distanceLimitative < premiereDLNonNulle) {
        if (surfaceFacade >= surfacesDisponibles[0]) {
            // Étape 1: Interpolation pour la surface à DL=0
            const pourcentage0 = 0; // À DL=0, le pourcentage est toujours 0
            
            // Étape 2: Interpolation pour la surface à première DL non-nulle
            const indexPremiereDL = distances.indexOf(premiereDLNonNulle);
            
            // Trouver les surfaces encadrantes
            const surfacesEncadrantes = trouverValeurEncadrantes(surfaceFacade, surfacesDisponibles);
            const surfaceInferieure = surfacesEncadrantes.inferieure;
            const surfaceSuperieure = surfacesEncadrantes.superieure;
            let keyInf, keySup;
            
            if (surfaceFacade === surfaceInferieure && surfaceInferieure === surfaceSuperieure) {
                keyInf = keySup = surfaceInferieure.toString();
            } else if (surfaceFacade > surfacesDisponibles[surfacesDisponibles.length - 1]) {
                keyInf = surfacesDisponibles[surfacesDisponibles.length - 1].toString();
                keySup = ">100";
            } else {
                keyInf = surfaceInferieure.toString();
                keySup = surfaceSuperieure.toString();
            }
            
            let pourcentageDLMin;
            
            if (keyInf === keySup) {
                pourcentageDLMin = tableau.surfaces[keyInf][indexPremiereDL];
            } else {
                const pourcentageDLMin_SurfInf = tableau.surfaces[keyInf][indexPremiereDL];
                const pourcentageDLMin_SurfSup = tableau.surfaces[keySup][indexPremiereDL];
                
                pourcentageDLMin = pourcentageDLMin_SurfSup + 
                    ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
                    (pourcentageDLMin_SurfInf - pourcentageDLMin_SurfSup);
            }
            
            // Étape 3: Extrapolation entre DL=0 et première DL non-nulle
            const pente = (pourcentageDLMin - pourcentage0) / premiereDLNonNulle;
            let pourcentageFinal = pourcentage0 + (pente * distanceLimitative);
            
            // Appliquer la majoration si nécessaire
            if (avecMajoration || avecGicleurs) {
                pourcentageFinal = Math.min(100, pourcentageFinal * 2);
            }
            
            return Math.max(0, Math.min(100, pourcentageFinal));
        } else {
            // Cas particulier 3: petite distance limitative et petite surface
            // Étape 1: Extrapolation pour la 1ère surface à la distance donnée
            const pourcentage0_FDR1 = 0;
            const indexPremiereDL = distances.indexOf(premiereDLNonNulle);
            const pourcentageDLMin_FDR1 = tableau.surfaces[surfacesDisponibles[0].toString()][indexPremiereDL];
            
            const pente1 = (pourcentageDLMin_FDR1 - pourcentage0_FDR1) / premiereDLNonNulle;
            const pourcentageFDR1 = pourcentage0_FDR1 + (pente1 * distanceLimitative);
            
            // Étape 2: Extrapolation pour la 2ème surface à la distance donnée
            const pourcentage0_FDR2 = 0;
            const pourcentageDLMin_FDR2 = tableau.surfaces[surfacesDisponibles[1].toString()][indexPremiereDL];
            
            const pente2 = (pourcentageDLMin_FDR2 - pourcentage0_FDR2) / premiereDLNonNulle;
            const pourcentageFDR2 = pourcentage0_FDR2 + (pente2 * distanceLimitative);
            
            // Étape 3: Extrapolation pour la surface réelle
            let pourcentageFinal = pourcentageFDR2 + 
                ((surfaceFacade - surfacesDisponibles[1]) / (surfacesDisponibles[0] - surfacesDisponibles[1])) * 
                (pourcentageFDR1 - pourcentageFDR2);
            
            // Appliquer la majoration si nécessaire
            if (avecMajoration || avecGicleurs) {
                pourcentageFinal = Math.min(100, pourcentageFinal * 2);
            }
            
            return Math.max(0, Math.min(100, pourcentageFinal));
        }
    }
    
    // Trouver les distances encadrantes
    const distancesEncadrantes = trouverValeurEncadrantes(distanceLimitative, distances);
    const distanceInferieure = distancesEncadrantes.inferieure;
    const distanceSuperieure = distancesEncadrantes.superieure;
    const distanceInferieureIndex = distances.indexOf(distanceInferieure);
    const distanceSuperieureIndex = distances.indexOf(distanceSuperieure);
    const extrapolationDistance = distancesEncadrantes.extrapolation;
    const distanceExacte = distancesEncadrantes.valeurExacte;
    
    // Trouver les surfaces encadrantes
    let surfaceInferieure, surfaceSuperieure;
    let keyInf, keySup;
    
    if (surfaceFacade <= surfacesDisponibles[0]) {
        // Cas spécial: extrapolation pour petites surfaces (< 30m²)
        if (surfaceFacade < surfacesDisponibles[0]) {
            surfaceInferieure = surfaceFacade;
            surfaceSuperieure = surfacesDisponibles[0];
            keyInf = "extrapolation";
            keySup = surfacesDisponibles[0].toString();
        } else {
            surfaceInferieure = surfaceSuperieure = surfacesDisponibles[0];
            keyInf = keySup = surfacesDisponibles[0].toString();
        }
    } else if (surfaceFacade > surfacesDisponibles[surfacesDisponibles.length - 1]) {
        surfaceInferieure = surfacesDisponibles[surfacesDisponibles.length - 1];
        surfaceSuperieure = Infinity;
        keyInf = surfacesDisponibles[surfacesDisponibles.length - 1].toString();
        keySup = ">100";
    } else {
        for (let i = 0; i < surfacesDisponibles.length - 1; i++) {
            if (surfaceFacade > surfacesDisponibles[i] && surfaceFacade <= surfacesDisponibles[i + 1]) {
                surfaceInferieure = surfacesDisponibles[i];
                surfaceSuperieure = surfacesDisponibles[i + 1];
                keyInf = surfaceInferieure.toString();
                keySup = surfaceSuperieure.toString();
                break;
            }
        }
    }
    
    // Cas spécial: extrapolation pour distance limitative entre 0 et 1.2m
    if (extrapolationDistance) {
        let pourcentageDistance0 = 0; // Toujours 0% quand DL=0
        let pourcentageDistanceMin;
        
        // Vérifier si on a aussi une extrapolation de surface
        if (keyInf === "extrapolation") {
            // Double extrapolation (distance et surface)
            
            // D'abord déterminer le pourcentage pour la surface minimale du tableau à la distance minimale
            const pourcentageDistMinSurfMin = tableau.surfaces[keySup][distanceSuperieureIndex];
            const pourcentageDistMinSurfSupMin = tableau.surfaces[Object.keys(tableau.surfaces)[1]][distanceSuperieureIndex];
            
            // Extrapolation pour surface plus petite (avec la plus petite distance non-nulle)
            pourcentageDistanceMin = extrapolerPourcentageSurface(
                pourcentageDistMinSurfMin,
                pourcentageDistMinSurfSupMin,
                surfaceSuperieure,
                surfaceFacade
            );
        } else if (keyInf === keySup) {
            // Extrapolation de distance uniquement (surface dans le tableau)
            pourcentageDistanceMin = tableau.surfaces[keyInf][distanceSuperieureIndex];
        } else {
            // Extrapolation de distance et interpolation de surface
            const pourcentageDistMinSurfInf = tableau.surfaces[keyInf][distanceSuperieureIndex];
            const pourcentageDistMinSurfSup = tableau.surfaces[keySup][distanceSuperieureIndex];
            
            // Interpolation entre les surfaces à la distance minimale
            pourcentageDistanceMin = pourcentageDistMinSurfSup + 
                ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
                (pourcentageDistMinSurfInf - pourcentageDistMinSurfSup);
        }
        
        // Extrapolation entre 0 et la première distance non-nulle
        let pourcentageFinal = extrapolerPourcentage(
            pourcentageDistance0,
            pourcentageDistanceMin,
            distanceSuperieure,
            distanceExacte
        );
        
        // Appliquer la majoration si nécessaire
        if (avecMajoration || avecGicleurs) {
            pourcentageFinal = Math.min(100, pourcentageFinal * 2);
        }
        
        return Math.max(0, Math.min(100, pourcentageFinal));
    }
    
    // Cas spécial: extrapolation pour petites surfaces (< 30m²)
    if (keyInf === "extrapolation") {
        const pourcentageDistInfSurfMin = tableau.surfaces[keySup][distanceInferieureIndex];
        const pourcentageDistInfSurfSupMin = tableau.surfaces[Object.keys(tableau.surfaces)[1]][distanceInferieureIndex];
        
        // Extrapolation pour surface plus petite
        let pourcentageFinal = extrapolerPourcentageSurface(
            pourcentageDistInfSurfMin,
            pourcentageDistInfSurfSupMin,
            surfaceSuperieure, // Surface min du tableau
            surfaceFacade
        );
        
        // Appliquer la majoration si nécessaire
        if (avecMajoration || avecGicleurs) {
            pourcentageFinal = Math.min(100, pourcentageFinal * 2);
        }
        
        return Math.max(0, Math.min(100, pourcentageFinal));
    }
    
    // ÉTAPE 1: Interpolation selon la DL inférieure - MODIFIÉE
    let pourcentageDistanceInferieure;
    
    if (keyInf === keySup) {
        pourcentageDistanceInferieure = tableau.surfaces[keyInf][distanceInferieureIndex];
    } else {
        const pourcentageDistInfSurfInf = tableau.surfaces[keyInf][distanceInferieureIndex];
        const pourcentageDistInfSurfSup = tableau.surfaces[keySup][distanceInferieureIndex];
        
        // Formule MODIFIÉE selon la méthodologie de référence
        pourcentageDistanceInferieure = pourcentageDistInfSurfSup + 
            ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageDistInfSurfInf - pourcentageDistInfSurfSup);
    }

    // Si les distances sont identiques, pas besoin d'interpolation complexe
    if (distanceInferieure === distanceSuperieure) {
        let resultat = pourcentageDistanceInferieure;
        
        // Appliquer la majoration si nécessaire (briques de verre, verre armé ou gicleurs)
        if (avecMajoration || avecGicleurs) {
            resultat = Math.min(100, resultat * 2);
        }
        
        return resultat;
    }
    
    // ÉTAPE 2: Interpolation selon la DL supérieure - MODIFIÉE
    let pourcentageDistanceSuperieure;
    
    if (keyInf === keySup) {
        pourcentageDistanceSuperieure = tableau.surfaces[keyInf][distanceSuperieureIndex];
    } else {
        const pourcentageDistSupSurfInf = tableau.surfaces[keyInf][distanceSuperieureIndex];
        const pourcentageDistSupSurfSup = tableau.surfaces[keySup][distanceSuperieureIndex];
        
        // Formule MODIFIÉE selon la méthodologie de référence
        pourcentageDistanceSuperieure = pourcentageDistSupSurfSup + 
            ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageDistSupSurfInf - pourcentageDistSupSurfSup);
    }
    
    // ÉTAPE 3: Interpolation finale entre les deux résultats d'interpolation précédents
    let pourcentageFinal = pourcentageDistanceInferieure + 
        ((distanceLimitative - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
        (pourcentageDistanceSuperieure - pourcentageDistanceInferieure);
    
    // Appliquer la formule spéciale pour les grandes surfaces si la distance est >= 1.2 m
    if (surfaceFacade > surfacesDisponibles[surfacesDisponibles.length - 1] && distanceLimitative >= 1.2) {
        // Pour le tableau 9.10.14.4-A avec usage "habitation" ou pour 9.10.15.4
        if (!tableau.hasOwnProperty("usages") || tableau.usages === "habitation") {
            pourcentageFinal = Math.pow(distanceLimitative, 2);
        } else { // Pour le tableau 9.10.14.4-A avec usage "commercial"
            pourcentageFinal = 0.5 * Math.pow(distanceLimitative, 2);
        }
    }
    
    // Appliquer la majoration si nécessaire (briques de verre, verre armé ou gicleurs)
    if (avecMajoration || avecGicleurs) {
        pourcentageFinal = Math.min(100, pourcentageFinal * 2);
    }
    
    // Limiter le pourcentage final entre 0 et 100
    return Math.max(0, Math.min(100, pourcentageFinal));
}

// Fonction pour calculer le pourcentage de baies non protégées selon CNB
function calculerPourcentageCNB(usage, distanceLimitative, surfaceFacade, length, height, avecGicleurs, glassBrick) {
    // Déterminer le rapport L/H
    const rapportLH = determinerRapportLH(length, height);
    
    // Calculer le pourcentage de base
    let pourcentage = interpolationCNB(
        usage, 
        distanceLimitative, 
        surfaceFacade, 
        rapportLH, 
        avecGicleurs
    );
    
    // Appliquer la majoration pour briques de verre/verre armé si nécessaire
    if (glassBrick) {
        pourcentage = Math.min(100, pourcentage * 2);
    }
    
    return pourcentage;
}

// Version spécifique pour 9.10.14 - MODIFIÉE pour utiliser la fonction calculerPourcentage910x corrigée
function calculerPourcentage91014(usage, distanceLimitative, surfaceFacade, avecGicleurs, avecMajoration) {
    const tableau = {
        usages: usage,
        surfaces: tableau91014[usage].surfaces,
        distances: tableau91014[usage].distances
    };
    
    return calculerPourcentage910x(tableau, distanceLimitative, surfaceFacade, avecGicleurs, avecMajoration);
}

// Version spécifique pour 9.10.15 - MODIFIÉE pour utiliser la fonction calculerPourcentage910x corrigée
function calculerPourcentage91015(distanceLimitative, surfaceFacade, avecGicleurs, avecMajoration) {
    return calculerPourcentage910x(tableau91015, distanceLimitative, surfaceFacade, avecGicleurs, avecMajoration);
}

function calculateCNB() {
    const facadeSurface = parseFloat(document.getElementById('surface_cnb').value);
    const length = parseFloat(document.getElementById('length_cnb').value);
    const height = parseFloat(document.getElementById('height_cnb').value);
    let limitingDistance = parseFloat(document.getElementById('distance_cnb').value);
    const sprinklersOption = document.getElementById('sprinklers_cnb').value;
    const response = document.getElementById('response_cnb').checked;
    const usage = document.getElementById('usage_cnb').value;
    const constructionType = document.getElementById('construction_type_cnb').value;
    const revetementType = document.getElementById('revetement_type_cnb').value;
    const glassBrick = document.getElementById('glass_brick_cnb').checked;
    const exemptBuilding = document.getElementById('exempt_building_cnb').value;
    const proposedArea = parseFloat(document.getElementById('proposed_area_cnb').value);
    const checkSpacing = document.getElementById('check_spacing_cnb').checked;
    const horizontalSpacing = parseFloat(document.getElementById('horizontal_spacing_cnb').value);
    const verticalSpacing = parseFloat(document.getElementById('vertical_spacing_cnb').value);
    const checkSoffit = document.getElementById('check_soffit_cnb').checked;
    const soffit_distance = parseFloat(document.getElementById('soffit_distance_cnb').value);
    const soffit_protected = document.getElementById('soffit_protected_cnb').checked;
    
    // Vérification des entrées
    if (isNaN(facadeSurface) || isNaN(length) || isNaN(height) || isNaN(limitingDistance) || 
        facadeSurface <= 0 || length <= 0 || height <= 0 || limitingDistance < 0) {
        document.getElementById('cnb-result').innerHTML = "Erreur : Veuillez entrer des valeurs numériques valides.";
        return;
    }
    
    // Vérifier si le bâtiment est exempté
    if (exemptBuilding !== "none") {
        let exemptMessage = "";
        if (exemptBuilding === "parking" && limitingDistance >= 3) {
            exemptMessage = `
                <strong>Bâtiment exempté - Garage de stationnement à étages ouverts :</strong><br>
                Selon l'article 3.2.3.10. 1), les façades de rayonnement d'un garage de stationnement dont 
                tous les étages sont des étages ouverts peuvent comporter des baies non protégées sans 
                limitation de surface si la distance limitative est d'au moins 3 m.<br><br>
                <strong>Surface maximale des baies non protégées : 100%</strong>
            `;
        } else if (exemptBuilding === "street_level" && limitingDistance >= 9) {
            exemptMessage = `
                <strong>Bâtiment exempté - Façade donnant sur une rue :</strong><br>
                Selon l'article 3.2.3.10. 2), la partie de la façade de rayonnement donnant sur une rue peut 
                comporter, à l'étage qui se trouve au niveau de la rue, des baies non protégées sans 
                limitation de surface si la distance limitative est d'au moins 9 m.<br><br>
                <strong>Surface maximale des baies non protégées : 100%</strong>
            `;
        } else {
            exemptMessage = `
                <strong>Bâtiment exempté - Conditions non satisfaites :</strong><br>
                Le bâtiment que vous avez sélectionné pourrait être exempté, mais les conditions ne sont pas satisfaites.<br>
                ${exemptBuilding === "parking" ? 
                    "- Pour un garage de stationnement à étages ouverts, la distance limitative doit être d'au moins 3 m." : 
                    "- Pour une façade donnant sur une rue, la distance limitative doit être d'au moins 9 m."}
            `;
        }
        
        if (exemptMessage.includes("100%")) {
            document.getElementById('copy_cnb').style.display = 'inline-block';
            document.getElementById('cnb-result').innerHTML = exemptMessage;
            return;
        }
        // Si non exempté, on continue avec le calcul normal
    }

    // Ajustement pour le délai d'intervention
    if (response) {
        limitingDistance = limitingDistance / 2;
    }

    // Utiliser la nouvelle méthode de calcul CNB
    const avecGicleurs = sprinklersOption === "complete";
    let pourcentage = calculerPourcentageCNB(
        usage, 
        limitingDistance, 
        facadeSurface, 
        length, 
        height, 
        avecGicleurs, 
        glassBrick
    );
    
    // Ajouter les précisions concernant 3.1.7.2. 1) et 3.2.3.1. 9) lorsque la distance limitative est < 1,2 m
    let rayonnementInfo = "";
    if (limitingDistance < 1.2) {
        rayonnementInfo = `
            <br><strong>Note concernant le rayonnement thermique :</strong><br>
            Selon l'article 3.1.7.2. 1), la limite d'élévation de température sur la face non exposée d'une construction ne s'applique pas 
            à un mur extérieur ayant une distance limitative de 1,2 m ou plus, pourvu que le rayonnement émis par la face non exposée 
            soit pris en compte pour effectuer une correction conformément au paragraphe 3.2.3.1. 9).<br>
            <br>
            Selon le paragraphe 3.2.3.1. 9), si la température superficielle de la face non exposée d'un mur dépasse les valeurs établies 
            par les essais normalisés de résistance au feu, il faut tenir compte du rayonnement émis par la face non exposée du mur en 
            ajoutant une surface équivalente de baies non protégées.
        `;
    }
    
    // Calculer la surface maximale de baies non protégées
    const maxArea = (pourcentage / 100) * facadeSurface;
    
    // Déterminer les exigences de construction selon 3.2.3.7
    let constructionRequirements = determineConstructionRequirements(pourcentage, usage, constructionType, revetementType);
    
    // Vérification de l'espacement des baies
    let spacingResult = "";
    if (checkSpacing) {
        const minHorizontalSpacing = 2.0; // En mètres selon 3.2.3.1.(6)
        const minVerticalSpacing = 2.0;   // En mètres selon 3.2.3.1.(6)
        
        if (horizontalSpacing < minHorizontalSpacing || verticalSpacing < minVerticalSpacing) {
            spacingResult = `
                <br><strong>Vérification de l'espacement des baies :</strong><br>
                ⚠️ <span style="color: red;">NON CONFORME</span> - L'espacement des baies ne respecte pas les exigences minimales.<br>
                Selon l'article 3.2.3.1.(6), l'espacement des baies non protégées desservant une même pièce doit être d'au moins :<br>
                - 2 m horizontalement (valeur saisie: ${horizontalSpacing} m)<br>
                - 2 m verticalement (valeur saisie: ${verticalSpacing} m)
            `;
        } else {
            spacingResult = `
                <br><strong>Vérification de l'espacement des baies :</strong><br>
                <span style="color: green;">CONFORME</span> - L'espacement des baies respecte les exigences minimales.<br>
                Espacement horizontal: ${horizontalSpacing} m (minimum requis: 2 m)<br>
                Espacement vertical: ${verticalSpacing} m (minimum requis: 2 m)
            `;
        }
    }
    
    // Vérification de la protection des soffites
    let soffitResult = "";
    if (checkSoffit) {
        if (soffit_distance < 0.45) {
            soffitResult = `
                <br><strong>Protection des soffites :</strong><br>
                Selon l'article 3.2.3.6.(2), aucun soffite ne doit faire saillie au-dessus de la façade de rayonnement
                lorsque la distance limitative est inférieure à 0,45 m.<br>
                ${soffit_distance < 0.45 ? 
                    "⚠️ <span style=\"color: red;\">La distance du soffite (" + soffit_distance + " m) est inférieure à 0,45 m. Aucun soffite n'est autorisé.</span>" : 
                    "La distance du soffite est conforme."}
            `;
        } else if (soffit_distance < 1.2) {
            soffitResult = `
                <br><strong>Protection des soffites :</strong><br>
                Selon l'article 3.2.3.6.(3-5), si la distance limitative est entre 0,45 m et 1,2 m, les soffites de toit 
                ne doivent pas faire saillie à moins de 0,45 m de la limite de propriété, ou doivent être protégés.<br>
                ${soffit_distance < 0.45 ? 
                    "⚠️ <span style=\"color: red;\">La distance du soffite (" + soffit_distance + " m) est inférieure à 0,45 m. Une protection est requise.</span>" : 
                    "La distance du soffite est d'au moins 0,45 m."}
                ${!soffit_protected && soffit_distance < 0.45 ? 
                    "<br>⚠️ <span style=\"color: green;\">Le soffite est protégé selon les exigences.</span>" : ""}
            `;
        } else {
            soffitResult = `
                <br><strong>Protection des soffites :</strong><br>
                <span style="color: green;">La distance du soffite (${soffit_distance} m) est supérieure à 1,2 m. 
                Aucune protection spécifique n'est requise.</span>
            `;
        }
    }

    // Ajouter une mention spéciale si on a fait une extrapolation
    let extrapolationInfo = "";
    if (facadeSurface < 10 || (limitingDistance > 0 && limitingDistance < 1.2)) {
        extrapolationInfo = `
            <br><strong>Remarque sur le calcul :</strong><br>
            ${facadeSurface < 10 ? "La surface de la façade de rayonnement (" + facadeSurface.toFixed(2) + " m²) est inférieure à la valeur minimale du tableau de référence (10 m²).<br>" : ""}
            ${limitingDistance > 0 && limitingDistance < 1.2 ? "La distance limitative (" + limitingDistance.toFixed(2) + " m) est inférieure à la valeur minimale non-nulle du tableau de référence (1,2 m).<br>" : ""}
            Une extrapolation a été effectuée pour obtenir un résultat plus précis.
        `;
    }

   // Afficher les résultats détaillés avec les calculs intermédiaires
   let resultHTML = `
   <strong>Données de calcul :</strong><br>
   ${response ? "Distance limitative ajustée : " + limitingDistance.toFixed(2) + " m<br>" : ""}
   Rapport L/H ou H/L : ${determinerRapportLH(length, height)}<br>
   Type de construction : ${constructionType}<br>
   Type de revêtement : ${revetementType}<br>
   Protection par gicleurs : ${sprinklersOption === "complete" ? "Complète" : sprinklersOption === "partial" ? "Partielle" : "Aucune"}<br>
   ${glassBrick ? "Majoration pour briques de verre/verre armé appliquée (x2)<br>" : ""}
   
   <br><strong>Résultats :</strong><br>
   Pourcentage maximal de baies non protégées : ${pourcentage.toFixed(2)}%<br>
   Surface maximale de baies non protégées : ${maxArea.toFixed(2)} m²
   ${constructionRequirements}
   ${extrapolationInfo}
   ${rayonnementInfo}
   ${spacingResult}
   ${soffitResult}
`;

    // Ajouter la comparaison avec la surface proposée
    if (!isNaN(proposedArea) && proposedArea > 0) {
        const proposedPercentage = (proposedArea / facadeSurface) * 100;
        let statusClass = "";
        let comparisonResult = "";
        
        if (proposedPercentage > pourcentage) {
            statusClass = "color: red; font-weight: bold;";
            comparisonResult = `
                <br><br><strong>Comparaison avec la surface proposée:</strong><br>
                Votre proposition: ${proposedArea.toFixed(2)} m² (${proposedPercentage.toFixed(2)}% de la façade)<br>
                <span style="${statusClass}">⚠️ La surface proposée dépasse le maximum autorisé de ${maxArea.toFixed(2)} m² (${pourcentage.toFixed(2)}%).</span>
            `;
        } else {
            statusClass = "color: green; font-weight: bold;";
            comparisonResult = `
                <br><br><strong>Comparaison avec la surface proposée:</strong><br>
                Votre proposition: ${proposedArea.toFixed(2)} m² (${proposedPercentage.toFixed(2)}% de la façade)<br>
                <span style="${statusClass}">La surface proposée respecte le maximum autorisé de ${maxArea.toFixed(2)} m² (${pourcentage.toFixed(2)}%).</span>
            `;
        }
        
        // Ajouter le résultat de comparaison à resultHTML
        resultHTML += comparisonResult;
    }
    
    // Ajouter le message de dégagement de responsabilité
    resultHTML += `
    <br><br><div style="font-style: italic; padding: 10px; border-top: 1px solid #ccc; margin-top: 10px;">
    <strong>Avis de non-responsabilité:</strong> Les résultats générés par cet outil sont fournis à titre indicatif uniquement. 
    L'utilisateur demeure responsable de valider leur conformité auprès d'un professionnel qualifié ou de l'autorité compétente en matière de sécurité incendie.
    </div>
`;           
    document.getElementById('cnb-result').innerHTML = resultHTML;
    document.getElementById('copy_cnb').style.display = 'inline-block';
}
