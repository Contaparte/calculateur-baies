// Tableau 3.2.3.1.-B - Usages des groupes A, B3, C, D et F3 - Sans gicleurs
   const tableauGroupesAB3CDF3 = {
       10: {
           "< 3:1": [0, 8, 10, 18, 29, 46, 91, 100],
           "3:1 à 10:1": [0, 8, 12, 21, 33, 50, 96, 100],
           "> 10:1": [0, 11, 18, 32, 48, 68, 100]
       },
       15: {
           "< 3:1": [0, 7, 9, 14, 22, 33, 63, 100],
           "3:1 à 10:1": [0, 8, 10, 17, 25, 37, 67, 100],
           "> 10:1": [0, 10, 15, 26, 39, 53, 87, 100]
       },
       20: {
           "< 3:1": [0, 7, 9, 12, 18, 26, 49, 81, 100],
           "3:1 à 10:1": [0, 8, 10, 15, 21, 30, 53, 85, 100],
           "> 10:1": [0, 9, 14, 23, 33, 45, 72, 100]
       },
       25: {
           "< 3:1": [0, 7, 8, 11, 16, 23, 41, 66, 98, 100],
           "3:1 à 10:1": [0, 8, 9, 13, 19, 26, 45, 70, 100],
           "> 10:1": [0, 9, 13, 21, 30, 39, 62, 90, 100]
       },
       30: {
           "< 3:1": [0, 7, 8, 11, 15, 20, 35, 56, 83, 100],
           "3:1 à 10:1": [0, 7, 9, 12, 17, 23, 39, 61, 88, 100],
           "> 10:1": [0, 8, 12, 19, 27, 36, 56, 79, 100]
       },
       40: {
           "< 3:1": [0, 7, 8, 10, 13, 17, 28, 44, 64, 89, 100],
           "3:1 à 10:1": [0, 7, 8, 11, 15, 20, 32, 48, 69, 93, 100],
           "> 10:1": [0, 8, 11, 17, 24, 31, 47, 66, 88, 100]
       },
       50: {
           "< 3:1": [0, 7, 8, 9, 12, 15, 24, 37, 53, 72, 96, 100],
           "3:1 à 10:1": [0, 7, 8, 10, 14, 18, 28, 41, 57, 77, 100],
           "> 10:1": [0, 8, 10, 15, 21, 28, 41, 57, 76, 97, 100]
       },
       60: {
           "< 3:1": [0, 7, 8, 9, 11, 14, 21, 32, 45, 62, 81, 100],
           "3:1 à 10:1": [0, 7, 8, 10, 13, 16, 25, 36, 49, 66, 85, 100],
           "> 10:1": [0, 8, 10, 14, 20, 25, 38, 51, 67, 85, 100]
       },
       80: {
           "< 3:1": [0, 7, 7, 8, 10, 12, 18, 26, 36, 48, 62, 79, 98, 100],
           "3:1 à 10:1": [0, 7, 8, 9, 11, 14, 21, 29, 40, 52, 67, 84, 100],
           "> 10:1": [0, 8, 9, 13, 17, 22, 32, 44, 56, 70, 86, 100]
       },
       100: {
           "< 3:1": [0, 7, 7, 8, 9, 11, 16, 22, 30, 40, 51, 65, 80, 97, 100],
           "3:1 à 10:1": [0, 7, 8, 9, 11, 13, 18, 25, 34, 44, 56, 69, 84, 100],
           "> 10:1": [0, 7, 9, 12, 16, 20, 29, 39, 49, 61, 74, 89, 100]
       },
       150: {
           "< 3:1": [0, 7, 7, 8, 9, 10, 13, 17, 22, 29, 37, 46, 56, 67, 79, 93, 100],
           "3:1 à 10:1": [0, 7, 7, 8, 10, 11, 15, 20, 26, 33, 41, 50, 60, 71, 84, 97, 100],
           "> 10:1": [0, 7, 8, 11, 13, 17, 24, 31, 39, 48, 57, 68, 79, 91, 100]
       },
       250: {
           "< 3:1": [0, 7, 7, 7, 8, 9, 10, 13, 16, 20, 25, 30, 36, 43, 51, 59, 68, 87, 100],
           "3:1 à 10:1": [0, 7, 7, 8, 9, 10, 12, 15, 19, 24, 28, 34, 40, 47, 55, 63, 72, 92, 100],
           "> 10:1": [0, 7, 8, 9, 11, 14, 19, 24, 30, 36, 43, 50, 57, 65, 73, 82, 92, 100]
       },
       350: {
           "< 3:1": [0, 7, 7, 7, 8, 8, 9, 11, 14, 16, 20, 24, 28, 33, 38, 44, 50, 64, 81, 99, 100],
           "3:1 à 10:1": [0, 7, 7, 8, 8, 9, 11, 13, 16, 19, 23, 27, 32, 37, 42, 48, 55, 69, 85, 100],
           "> 10:1": [0, 7, 8, 9, 10, 12, 16, 21, 25, 30, 36, 41, 47, 53, 59, 66, 73, 88, 100]
       },
       500: {
           "< 3:1": [0, 7, 7, 7, 7, 8, 9, 10, 12, 14, 16, 19, 22, 25, 29, 33, 37, 47, 59, 71, 100],
           "3:1 à 10:1": [0, 7, 7, 7, 8, 8, 10, 12, 14, 16, 19, 22, 25, 29, 33, 37, 41, 52, 63, 76, 100],
           "> 10:1": [0, 7, 7, 8, 9, 11, 14, 18, 22, 25, 30, 34, 38, 43, 48, 53, 58, 70, 82, 96, 100]
       },
       1000: {
           "< 3:1": [0, 7, 7, 7, 7, 7, 8, 9, 9, 10, 12, 13, 14, 16, 18, 20, 22, 27, 33, 39, 58, 82, 100],
           "3:1 à 10:1": [0, 7, 7, 7, 7, 8, 9, 10, 11, 12, 14, 15, 17, 19, 21, 23, 26, 31, 37, 43, 63, 86, 100],
           "> 10:1": [0, 7, 7, 8, 8, 9, 11, 13, 16, 19, 21, 24, 27, 30, 33, 36, 39, 46, 53, 60, 82, 100]
       },
       2000: {
           "< 3:1": [0, 7, 7, 7, 7, 7, 7, 8, 8, 9, 9, 10, 11, 12, 13, 14, 15, 17, 20, 23, 33, 44, 58, 74, 93, 100],
           "3:1 à 10:1": [0, 7, 7, 7, 7, 7, 8, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 23, 27, 37, 49, 63, 79, 97, 100],
           "> 10:1": [0, 7, 7, 7, 8, 8, 9, 11, 12, 14, 16, 18, 19, 21, 23, 25, 27, 32, 36, 40, 53, 66, 82, 99, 100]
       }
   };
   
   // Tableau 3.2.3.1.-C - Usages des groupes E, F1 et F2 - Sans gicleurs
   const tableauGroupesEF1F2 = {
       10: {
           "< 3:1": [0, 4, 5, 9, 15, 23, 46, 77, 100],
           "3:1 à 10:1": [0, 4, 6, 10, 17, 25, 48, 79, 100],
           "> 10:1": [0, 5, 9, 16, 24, 34, 58, 91, 100]
       },
       15: {
           "< 3:1": [0, 4, 5, 7, 11, 16, 32, 53, 79, 100],
           "3:1 à 10:1": [0, 4, 5, 8, 13, 18, 34, 55, 82, 100],
           "> 10:1": [0, 5, 8, 13, 19, 26, 43, 66, 93, 100]
       },
       20: {
           "< 3:1": [0, 4, 4, 6, 9, 13, 25, 40, 61, 85, 100],
           "3:1 à 10:1": [0, 4, 5, 7, 11, 15, 27, 43, 63, 87, 100],
           "> 10:1": [0, 5, 7, 11, 17, 22, 36, 53, 74, 99, 100]
       },
       25: {
           "< 3:1": [0, 4, 4, 6, 8, 11, 20, 33, 49, 69, 92, 100],
           "3:1 à 10:1": [0, 4, 5, 7, 9, 13, 22, 35, 51, 71, 94, 100],
           "> 10:1": [0, 4, 6, 10, 15, 20, 31, 45, 62, 82, 100]
       },
       30: {
           "< 3:1": [0, 4, 4, 5, 7, 10, 18, 28, 42, 58, 77, 100],
           "3:1 à 10:1": [0, 4, 4, 6, 9, 12, 20, 30, 44, 60, 80, 100],
           "> 10:1": [0, 4, 6, 10, 14, 18, 28, 40, 54, 71, 91, 100]
       },
       40: {
           "< 3:1": [0, 4, 4, 5, 6, 8, 14, 22, 32, 44, 59, 76, 94, 100],
           "3:1 à 10:1": [0, 4, 4, 6, 8, 10, 16, 24, 34, 47, 61, 78, 97, 100],
           "> 10:1": [0, 4, 5, 8, 12, 15, 23, 33, 44, 57, 72, 89, 100]
       },
       50: {
           "< 3:1": [0, 4, 4, 5, 6, 7, 12, 18, 26, 36, 48, 61, 76, 93, 100],
           "3:1 à 10:1": [0, 4, 4, 5, 7, 9, 14, 20, 29, 38, 50, 63, 79, 95, 100],
           "> 10:1": [0, 4, 5, 8, 11, 14, 21, 29, 38, 48, 61, 74, 90, 100]
       },
       60: {
           "< 3:1": [0, 4, 4, 4, 5, 7, 11, 16, 23, 31, 40, 52, 64, 78, 94, 100],
           "3:1 à 10:1": [0, 4, 4, 5, 6, 8, 12, 18, 25, 33, 43, 54, 66, 81, 96, 100],
           "> 10:1": [0, 4, 5, 7, 10, 13, 19, 26, 34, 43, 53, 64, 77, 92, 100]
       },
       80: {
           "< 3:1": [0, 4, 4, 4, 5, 6, 9, 13, 18, 24, 31, 40, 49, 60, 71, 84, 98, 100],
           "3:1 à 10:1": [0, 4, 4, 5, 6, 7, 10, 15, 20, 26, 33, 42, 51, 62, 74, 86, 100],
           "> 10:1": [0, 4, 5, 6, 9, 11, 16, 22, 28, 35, 43, 52, 62, 73, 85, 98, 100]
       },
       100: {
           "< 3:1": [0, 4, 4, 4, 5, 5, 8, 11, 15, 20, 26, 32, 40, 48, 58, 68, 79, 100],
           "3:1 à 10:1": [0, 4, 4, 4, 5, 6, 9, 13, 17, 22, 28, 35, 42, 51, 60, 70, 81, 100],
           "> 10:1": [0, 4, 4, 6, 8, 10, 14, 19, 25, 31, 37, 44, 52, 61, 71, 81, 92, 100]
       },
       150: {
           "< 3:1": [0, 4, 4, 4, 4, 5, 6, 8, 11, 14, 18, 23, 28, 33, 40, 46, 54, 70, 89, 100],
           "3:1 à 10:1": [0, 4, 4, 4, 5, 6, 8, 10, 13, 16, 20, 25, 30, 36, 42, 49, 56, 73, 92, 100],
           "> 10:1": [0, 4, 4, 5, 7, 8, 12, 16, 20, 24, 29, 34, 39, 46, 52, 59, 67, 84, 100]
       },
       250: {
           "< 3:1": [0, 4, 4, 4, 4, 4, 5, 7, 8, 10, 12, 15, 18, 22, 25, 29, 34, 44, 55, 68, 100],
           "3:1 à 10:1": [0, 4, 4, 4, 4, 5, 6, 8, 10, 12, 14, 17, 20, 24, 27, 32, 36, 46, 57, 70, 100],
         "> 10:1": [0, 4, 4, 5, 6, 7, 9, 12, 15, 18, 21, 25, 28, 32, 37, 41, 46, 56, 68, 81, 100]
       },
       350: {
           "< 3:1": [0, 4, 4, 4, 4, 4, 5, 6, 7, 8, 10, 12, 14, 16, 19, 22, 25, 32, 40, 49, 77, 100],
           "3:1 à 10:1": [0, 4, 4, 4, 4, 4, 5, 7, 8, 10, 12, 14, 16, 18, 21, 24, 27, 34, 43, 52, 79, 100],
           "> 10:1": [0, 4, 4, 4, 5, 6, 8, 10, 13, 15, 18, 21, 23, 26, 30, 33, 36, 44, 53, 62, 90, 100]
       },
       500: {
           "< 3:1": [0, 4, 4, 4, 4, 4, 4, 5, 6, 7, 8, 9, 11, 13, 14, 16, 19, 24, 29, 36, 55, 78, 100],
           "3:1 à 10:1": [0, 4, 4, 4, 4, 4, 5, 6, 7, 8, 9, 11, 13, 14, 16, 18, 21, 26, 31, 38, 57, 80, 100],
           "> 10:1": [0, 4, 4, 4, 5, 5, 7, 9, 11, 13, 15, 17, 19, 21, 24, 26, 29, 35, 41, 48, 68, 92, 100]
       },
       1000: {
           "< 3:1": [0, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 7, 8, 9, 10, 11, 14, 16, 20, 29, 41, 55, 71, 89, 100],
           "3:1 à 10:1": [0, 4, 4, 4, 4, 4, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15, 18, 22, 31, 43, 57, 73, 91, 100],
           "> 10:1": [0, 4, 4, 4, 4, 5, 6, 7, 8, 9, 11, 12, 13, 15, 16, 18, 20, 23, 26, 30, 41, 53, 68, 84, 100]
       },
       2000: {
           "< 3:1": [0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 6, 6, 7, 7, 9, 10, 12, 16, 22, 29, 37, 46, 56, 68, 80, 94, 100],
           "3:1 à 10:1": [0, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 6, 6, 7, 7, 8, 9, 10, 12, 13, 18, 24, 31, 39, 49, 59, 70, 83, 96, 100],
           "> 10:1": [0, 4, 4, 4, 4, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 18, 20, 26, 33, 41, 50, 59, 70, 81, 94, 100]
       }
   };
   
   // Tableau 3.2.3.1.-D - Bâtiment protégé par gicleurs - Usages des groupes A, B, C, D et F3
   const tableauAvecGicleursGroupesABCDF3 = {
       10: [0, 16, 24, 42, 66, 100],
       15: [0, 16, 20, 34, 50, 74, 100],
       20: [0, 16, 20, 30, 42, 60, 100],
       25: [0, 16, 18, 26, 38, 52, 90, 100],
       30: [0, 14, 18, 24, 34, 46, 78, 100],
       40: [0, 14, 16, 22, 30, 40, 64, 96, 100],
       50: [0, 14, 16, 20, 28, 36, 56, 82, 100],
       60: [0, 14, 16, 20, 26, 32, 50, 72, 98, 100],
       80: [0, 14, 16, 18, 22, 28, 42, 58, 80, 100],
       100: [0, 14, 16, 18, 22, 26, 36, 50, 68, 88, 100],
       150: [0, 14, 14, 16, 20, 22, 30, 40, 52, 66, 82, 100]
   };
   
   // Tableau 3.2.3.1.-E - Bâtiment protégé par gicleurs - Usages des groupes E, F1 et F2
   const tableauAvecGicleursGroupesEF1F2 = {
       10: [0, 8, 12, 20, 34, 50, 96, 100],
       15: [0, 8, 10, 16, 26, 36, 68, 100],
       20: [0, 8, 10, 14, 22, 30, 54, 86, 100],
       25: [0, 8, 10, 14, 18, 26, 44, 70, 100],
       30: [0, 8, 8, 12, 18, 24, 40, 60, 88, 100],
       40: [0, 8, 8, 12, 16, 20, 32, 48, 68, 94, 100],
       50: [0, 8, 8, 10, 14, 18, 28, 40, 58, 76, 100],
       60: [0, 8, 8, 10, 12, 16, 24, 36, 50, 66, 86, 100],
       80: [0, 8, 8, 10, 12, 14, 20, 30, 40, 52, 66, 84, 100],
       100: [0, 8, 8, 8, 10, 12, 18, 26, 34, 44, 56, 70, 84, 100],
       150: [0, 8, 8, 8, 10, 12, 16, 20, 26, 32, 40, 50, 60, 72, 84, 98, 100],
       200: [0, 8, 8, 8, 8, 10, 14, 18, 22, 28, 34, 42,50, 60, 68, 80, 92, 100]
   };

   const limitingDistancesNoSprinklers = [0, 1.2, 1.5, 2.0, 2.5, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 18, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70];
   const limitingDistancesWithSprinklersABCDF3 = [0, 1.2, 1.5, 2.0, 2.5, 3, 4, 5, 6, 7, 8, 9];
   const limitingDistancesWithSprinklersEF1F2 = [0, 1.2, 1.5, 2.0, 2.5, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
   const facadeSurfaces = [10, 15, 20, 25, 30, 40, 50, 60, 80, 100, 150, 250, 350, 500, 1000, 2000];
   const facadeSurfacesWithSprinklersABCDF3 = [10, 15, 20, 25, 30, 40, 50, 60, 80, 100, 150, 250, 350, 500, 1000, 2000];
   const facadeSurfacesWithSprinklersEF1F2 = [10, 15, 20, 25, 30, 40, 50, 60, 80, 100, 150, 200];

// Données du Tableau 9.10.14.4-A
const tableau91014 = {
    "habitation": {
        surfaces: {
            30: [0, 7, 9, 12, 39, 88, 100, 100, 100, 100, 100, 100, 100],
            40: [0, 7, 8, 11, 32, 69, 100, 100, 100, 100, 100, 100, 100],
            50: [0, 7, 8, 10, 28, 57, 100, 100, 100, 100, 100, 100, 100],
            100: [0, 7, 8, 9, 18, 34, 56, 84, 100, 100, 100, 100, 100],
            ">100": [0, 7, 7, 8, 12, 19, 28, 40, 55, 92, 100, 100, 100]
        },
        distances: [0, 1.2, 1.5, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 16.0, 20.0, 25.0, 30.0]
    },
    "commercial": {
        surfaces: {
            30: [0, 4, 4, 6, 20, 44, 80, 100, 100, 100, 100, 100, 100],
            40: [0, 4, 4, 6, 16, 34, 61, 97, 100, 100, 100, 100, 100],
            50: [0, 4, 4, 5, 14, 29, 50, 79, 100, 100, 100, 100, 100],
            100: [0, 4, 4, 4, 9, 17, 28, 42, 60, 100, 100, 100, 100],
            ">100": [0, 4, 4, 4, 6, 10, 14, 20, 27, 46, 70, 100, 100]
        },
        distances: [0, 1.2, 1.5, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 16.0, 20.0, 25.0, 30.0]
    }
};

// Données du Tableau 9.10.15.4
const tableau91015 = {
    surfaces: {
        30: [0, 7, 9, 12, 39, 88, 100, 100, 100, 100, 100],
        40: [0, 7, 8, 11, 32, 69, 100, 100, 100, 100, 100],
        50: [0, 7, 8, 10, 28, 57, 100, 100, 100, 100, 100],
        100: [0, 7, 8, 9, 18, 34, 56, 84, 100, 100, 100],
        ">100": [0, 7, 7, 8, 12, 19, 28, 40, 55, 92, 100]
    },
    distances: [0, 1.2, 1.5, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0, 16.0, 20.0]
};

   // Fonction pour calculer les dimensions automatiquement
function updateDimensions(event) {
    // Identifier quel champ vient d'être modifié
    const changedField = event.target.id;
    
    const surfaceField = document.getElementById('surface_cnb');
    const lengthField = document.getElementById('length_cnb');
    const heightField = document.getElementById('height_cnb');
    
    const surface = parseFloat(surfaceField.value);
    const length = parseFloat(lengthField.value);
    const height = parseFloat(heightField.value);
    
    // Ne pas faire de calcul si le champ actif est vidé
    if (event.target.value === "") {
        return;
    }
    
    // Ajuster selon le champ qui a été modifié
    if (changedField === 'surface_cnb') {
        // Si la surface est modifiée et que la longueur ou la hauteur existe, mettre à jour l'autre dimension
        if (!isNaN(length)) {
            // Calculer la hauteur
            const calculatedHeight = surface / length;
            heightField.value = calculatedHeight.toFixed(2).replace('.', ',');
        } else if (!isNaN(height)) {
            // Calculer la longueur
            const calculatedLength = surface / height;
            lengthField.value = calculatedLength.toFixed(2).replace('.', ',');
        }
    } else if (changedField === 'length_cnb') {
        // Si la longueur est modifiée
        if (!isNaN(surface)) {
            // Calculer la hauteur basée sur la surface
            const calculatedHeight = surface / length;
            heightField.value = calculatedHeight.toFixed(2).replace('.', ',');
        } else if (!isNaN(height)) {
            // Calculer la surface
            const calculatedSurface = length * height;
            surfaceField.value = calculatedSurface.toFixed(2).replace('.', ',');
        }
    } else if (changedField === 'height_cnb') {
        // Si la hauteur est modifiée
        if (!isNaN(surface)) {
            // Calculer la longueur basée sur la surface
            const calculatedLength = surface / height;
            lengthField.value = calculatedLength.toFixed(2).replace('.', ',');
        } else if (!isNaN(length)) {
            // Calculer la surface
            const calculatedSurface = length * height;
            surfaceField.value = calculatedSurface.toFixed(2).replace('.', ',');
        }
    }
}
// Afficher/masquer les options supplémentaires
document.addEventListener('DOMContentLoaded', function() {
    // Gestionnaires d'événements pour les checkboxes de vérification d'espacement
    document.getElementById('check_spacing_cnb').addEventListener('change', function() {
        document.getElementById('spacing_options_cnb').style.display = this.checked ? 'block' : 'none';
    });
                    
    document.getElementById('check_spacing_91014').addEventListener('change', function() {
        document.getElementById('spacing_options_91014').style.display = this.checked ? 'block' : 'none';
    });
    
    document.getElementById('check_spacing_91015').addEventListener('change', function() {
            document.getElementById('spacing_options_91015').style.display = this.checked ? 'block' : 'none';
        });
        
    // Gestionnaires d'événements pour les checkboxes de vérification des soffites
    document.getElementById('check_soffit_cnb').addEventListener('change', function() {
        document.getElementById('soffit_options_cnb').style.display = this.checked ? 'block' : 'none';
    });
        
    document.getElementById('check_soffit_91014').addEventListener('change', function() {
        document.getElementById('soffit_options_91014').style.display = this.checked ? 'block' : 'none';
    });
        
    document.getElementById('check_soffit_91015').addEventListener('change', function() {
        document.getElementById('soffit_options_91015').style.display = this.checked ? 'block' : 'none';
    });
        
    // Ajouter des écouteurs pour l'onglet CNB
    const cnbInputs = document.querySelectorAll('#cnb input[type="number"]');
    cnbInputs.forEach(input => {
        input.addEventListener('keypress', function(event) {
            handleEnterKey(event, calculateCNB);
        });
    });

    // Ajouter des écouteurs pour l'onglet 9.10.14
    const inputs91014 = document.querySelectorAll('#method91014 input[type="number"]');
    inputs91014.forEach(input => {
        input.addEventListener('keypress', function(event) {
            handleEnterKey(event, calculate91014);
        });
    });

    // Ajouter des écouteurs pour l'onglet 9.10.15
    const inputs91015 = document.querySelectorAll('#method91015 input[type="number"]');
    inputs91015.forEach(input => {
        input.addEventListener('keypress', function(event) {
            handleEnterKey(event, calculate91015);
        });
    });

    // Écouteurs d'événements pour le calcul automatique des dimensions
    document.getElementById('surface_cnb').addEventListener('input', updateDimensions);
    document.getElementById('length_cnb').addEventListener('input', updateDimensions);
    document.getElementById('height_cnb').addEventListener('input', updateDimensions);
});

// Fonction pour déterminer la catégorie du rapport L/H
function determinerRapportLH(longueur, hauteur) {
    const rapportLH = longueur / hauteur;
    const rapportHL = hauteur / longueur;
    const maxRapport = Math.max(rapportLH, rapportHL);
    
    if (maxRapport < 3) return "< 3:1";
    if (maxRapport <= 10) return "3:1 à 10:1";
    return "> 10:1";
}

// Fonction pour trouver les valeurs encadrantes dans un tableau - MODIFIÉE pour extrapolation
function trouverValeurEncadrantes(valeur, tableau) {
    // Cas particulier: valeur exactement 0
    if (valeur === 0) {
        return { inferieure: 0, superieure: 0, extrapolation: false };
    }
    
    // Cas où la valeur est inférieure au premier élément non-nul
    let premierElementNonNul = tableau.find(e => e > 0);
    if (valeur > 0 && valeur < premierElementNonNul) {
        return { 
            inferieure: 0, 
            superieure: premierElementNonNul, 
            extrapolation: true,
            valeurExacte: valeur
        };
    }
    
    // Si la valeur est inférieure au premier élément (et non nulle)
    if (valeur <= tableau[0]) {
        return { inferieure: tableau[0], superieure: tableau[0], extrapolation: false };
    }
    
    // Si la valeur est supérieure au dernier élément
    if (valeur >= tableau[tableau.length - 1]) {
        return { inferieure: tableau[tableau.length - 1], superieure: tableau[tableau.length - 1], extrapolation: false };
    }
    
    // Rechercher les bornes encadrantes
    for (let i = 0; i < tableau.length - 1; i++) {
        if (valeur >= tableau[i] && valeur <= tableau[i + 1]) {
            return { inferieure: tableau[i], superieure: tableau[i + 1], extrapolation: false };
        }
    }
    
    // En cas d'échec (ne devrait jamais arriver si les vérifications ci-dessus sont correctes)
    return { inferieure: tableau[0], superieure: tableau[1], extrapolation: false };
}

// Fonction pour l'extrapolation des valeurs entre 0 et la première valeur non-nulle
function extrapolerPourcentage(pourcentage0, pourcentageMin, distanceMin, distanceExacte) {
    // Avec distanceExacte entre 0 et distanceMin
    // Pourcentage à 0 est généralement 0 dans les tableaux
    const pente = (pourcentageMin - pourcentage0) / distanceMin;
    const pourcentageExtrapole = pourcentage0 + (pente * distanceExacte);
    return Math.max(0, pourcentageExtrapole); // Ne jamais retourner un pourcentage négatif
}

// Fonction pour l'extrapolation des valeurs pour des surfaces inférieures au minimum du tableau
function extrapolerPourcentageSurface(pourcentageSurfaceMin, pourcentageSurfaceSupMin, surfaceMin, surfaceExacte) {
    if (surfaceExacte >= surfaceMin) return pourcentageSurfaceMin;
    
    // Tendance observée: plus la surface est petite, plus le pourcentage permis est élevé
    // On utilise une extrapolation linéaire inverse
    const ratio = surfaceMin / surfaceExacte;
    const facteur = Math.sqrt(ratio); // Facteur modérateur pour éviter une croissance trop rapide
    
    // En se basant sur la différence entre les pourcentages aux deux premières surfaces du tableau
    const tendance = (pourcentageSurfaceMin - pourcentageSurfaceSupMin) * (facteur - 1);
    return Math.min(100, pourcentageSurfaceMin + tendance); // Limitée à 100%
}

// Fonction d'interpolation principale MODIFIÉE avec extrapolation
function interpolationCNB(usage, distanceLimitative, surfaceFacade, rapportLH, avecGicleurs) {
    // Déterminer les tableaux à utiliser en fonction de l'usage et de la présence de gicleurs
    let tableauUtilise, distancesUtilisees, surfacesUtilisees;
    
    if (avecGicleurs) {
        if (usage === "groupes_A_B3_C_D_F3") {
            tableauUtilise = tableauAvecGicleursGroupesABCDF3;
            distancesUtilisees = limitingDistancesWithSprinklersABCDF3;
            surfacesUtilisees = facadeSurfacesWithSprinklersABCDF3;
        } else { // groupes_E_F1_F2
            tableauUtilise = tableauAvecGicleursGroupesEF1F2;
            distancesUtilisees = limitingDistancesWithSprinklersEF1F2;
            surfacesUtilisees = facadeSurfacesWithSprinklersEF1F2;
        }
    } else {
        distancesUtilisees = limitingDistancesNoSprinklers;
        surfacesUtilisees = facadeSurfaces;
        if (usage === "groupes_A_B3_C_D_F3") {
            tableauUtilise = tableauGroupesAB3CDF3;
        } else { // groupes_E_F1_F2
            tableauUtilise = tableauGroupesEF1F2;
        }
    }
    
    // Vérifier si la distance limitative dépasse la plage du tableau
    if (distanceLimitative > distancesUtilisees[distancesUtilisees.length - 1]) {
        return 100; // 100% de baies non protégées autorisées
    }
    
    // ÉTAPE 0: Trouver les bornes d'encadrement pour la distance limitative
    const distancesEncadrantes = trouverValeurEncadrantes(distanceLimitative, distancesUtilisees);
    const distanceInferieure = distancesEncadrantes.inferieure;
    const distanceSuperieure = distancesEncadrantes.superieure;
    const distanceInferieureIndex = distancesUtilisees.indexOf(distanceInferieure);
    const distanceSuperieureIndex = distancesUtilisees.indexOf(distanceSuperieure);
    const extrapolationDistance = distancesEncadrantes.extrapolation;
    const distanceExacte = distancesEncadrantes.valeurExacte;
    
    // Trouver les surfaces encadrantes pour la façade de rayonnement
    const surfaceFacadeMin = Math.min(surfaceFacade, surfacesUtilisees[0]); // Pour l'extrapolation
    const surfacesEncadrantes = trouverValeurEncadrantes(surfaceFacade, surfacesUtilisees);
    const surfaceInferieure = surfacesEncadrantes.inferieure;
    const surfaceSuperieure = surfacesEncadrantes.superieure;
    
    // Cas spécial: extrapolation pour petites surfaces (< 10m²)
    const extrapolationSurface = surfaceFacade < surfacesUtilisees[0];
    
    // Cas spécial: extrapolation pour distance limitative entre 0 et 1.2m
    if (extrapolationDistance) {
        let pourcentageDistance0, pourcentageDistanceMin;
        
        if (extrapolationSurface) {
            // Double extrapolation (distance et surface)
            // D'abord extrapoler pour la surface minimale, puis pour la surface réelle
            
            // Pour distance = 0
            pourcentageDistance0 = 0; // Toujours 0% quand DL=0
            
            // Pour distance = min (1.2m)
            if (!avecGicleurs) {
                const pourcentageSurfMin = tableauUtilise[surfacesUtilisees[0]][rapportLH][distanceSuperieureIndex];
                const pourcentageSurfSupMin = tableauUtilise[surfacesUtilisees[1]][rapportLH][distanceSuperieureIndex];
                
                // Extrapolation pour surface plus petite avec distance min
                pourcentageDistanceMin = extrapolerPourcentageSurface(
                    pourcentageSurfMin, 
                    pourcentageSurfSupMin, 
                    surfacesUtilisees[0], 
                    surfaceFacade
                );
            } else {
                const pourcentageSurfMin = tableauUtilise[surfacesUtilisees[0]][distanceSuperieureIndex];
                const pourcentageSurfSupMin = tableauUtilise[surfacesUtilisees[1]][distanceSuperieureIndex];
                
                // Extrapolation pour surface plus petite avec distance min
                pourcentageDistanceMin = extrapolerPourcentageSurface(
                    pourcentageSurfMin, 
                    pourcentageSurfSupMin, 
                    surfacesUtilisees[0], 
                    surfaceFacade
                );
            }
        } else {
            // Extrapolation simple pour la distance uniquement
            pourcentageDistance0 = 0; // Toujours 0% quand DL=0
            
            if (!avecGicleurs) {
                pourcentageDistanceMin = tableauUtilise[surfaceInferieure][rapportLH][distanceSuperieureIndex];
            } else {
                pourcentageDistanceMin = tableauUtilise[surfaceInferieure][distanceSuperieureIndex];
            }
        }
        
        // Extrapolation entre 0 et la première distance non-nulle
        return extrapolerPourcentage(
            pourcentageDistance0, 
            pourcentageDistanceMin, 
            distanceSuperieure, 
            distanceExacte
        );
    }
    
    // Cas spécial: extrapolation pour petites surfaces (< 10m²)
    if (extrapolationSurface) {
        let pourcentageSurfaceMin, pourcentageSurfaceSupMin;
        
        if (!avecGicleurs) {
            pourcentageSurfaceMin = tableauUtilise[surfacesUtilisees[0]][rapportLH][distanceInferieureIndex];
            pourcentageSurfaceSupMin = tableauUtilise[surfacesUtilisees[1]][rapportLH][distanceInferieureIndex];
        } else {
            pourcentageSurfaceMin = tableauUtilise[surfacesUtilisees[0]][distanceInferieureIndex];
            pourcentageSurfaceSupMin = tableauUtilise[surfacesUtilisees[1]][distanceInferieureIndex];
        }
        
        return extrapolerPourcentageSurface(
            pourcentageSurfaceMin,
            pourcentageSurfaceSupMin,
            surfacesUtilisees[0],
            surfaceFacade
        );
    }
    
    // Si les distances sont identiques, pas besoin d'interpolation complexe
    if (distanceInferieure === distanceSuperieure) {
        return interpolationSurfaceUniquement(tableauUtilise, surfaceFacade, surfaceInferieure, 
               surfaceSuperieure, distanceInferieureIndex, rapportLH, avecGicleurs);
    }
    
    // Si les surfaces sont identiques, pas besoin d'interpolation complexe
    if (surfaceInferieure === surfaceSuperieure) {
        return interpolationDistanceUniquement(tableauUtilise, distanceLimitative, distanceInferieure, 
               distanceSuperieure, surfaceInferieure, distanceInferieureIndex, 
               distanceSuperieureIndex, rapportLH, avecGicleurs);
    }
    
    // ÉTAPE 1: Interpolation selon la DL inférieure - MODIFIÉE
    let pourcentageDistanceInferieure;
    
    if (!avecGicleurs) {
        const pourcentageSurfInfDistInf = tableauUtilise[surfaceInferieure][rapportLH][distanceInferieureIndex];
        const pourcentageSurfSupDistInf = tableauUtilise[surfaceSuperieure][rapportLH][distanceInferieureIndex];
        
        // Formule MODIFIÉE selon la méthodologie de référence
        pourcentageDistanceInferieure = pourcentageSurfSupDistInf + 
            ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistInf - pourcentageSurfSupDistInf);
    } else {
        const pourcentageSurfInfDistInf = tableauUtilise[surfaceInferieure][distanceInferieureIndex];
        const pourcentageSurfSupDistInf = tableauUtilise[surfaceSuperieure][distanceInferieureIndex];
        
        // Formule MODIFIÉE selon la méthodologie de référence
        pourcentageDistanceInferieure = pourcentageSurfSupDistInf + 
            ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistInf - pourcentageSurfSupDistInf);
    }
    
    // ÉTAPE 2: Interpolation selon la DL supérieure - MODIFIÉE
    let pourcentageDistanceSuperieure;
    
    if (!avecGicleurs) {
        const pourcentageSurfInfDistSup = tableauUtilise[surfaceInferieure][rapportLH][distanceSuperieureIndex];
        const pourcentageSurfSupDistSup = tableauUtilise[surfaceSuperieure][rapportLH][distanceSuperieureIndex];
        
        // Formule MODIFIÉE selon la méthodologie de référence
        pourcentageDistanceSuperieure = pourcentageSurfSupDistSup + 
            ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistSup - pourcentageSurfSupDistSup);
    } else {
        const pourcentageSurfInfDistSup = tableauUtilise[surfaceInferieure][distanceSuperieureIndex];
        const pourcentageSurfSupDistSup = tableauUtilise[surfaceSuperieure][distanceSuperieureIndex];
        
        // Formule MODIFIÉE selon la méthodologie de référence
        pourcentageDistanceSuperieure = pourcentageSurfSupDistSup + 
            ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistSup - pourcentageSurfSupDistSup);
    }
    
    // ÉTAPE 3: Interpolation finale entre les deux résultats d'interpolation précédents
    const pourcentageFinal = pourcentageDistanceInferieure + 
        ((distanceLimitative - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
        (pourcentageDistanceSuperieure - pourcentageDistanceInferieure);
    
    // Limiter le pourcentage final entre 0 et 100
    return Math.max(0, Math.min(100, pourcentageFinal));
}

// Fonction pour l'interpolation quand seule la surface varie (distance fixe)
function interpolationSurfaceUniquement(tableauUtilise, surfaceFacade, surfaceInferieure, 
                                      surfaceSuperieure, distanceIndex, rapportLH, avecGicleurs) {
    // Cas spécial: extrapolation pour petites surfaces (< 10m²)
    const extrapolationSurface = surfaceFacade < surfaceInferieure && surfaceInferieure === Math.min(...facadeSurfaces);
    
    if (extrapolationSurface) {
        let pourcentageSurfaceMin, pourcentageSurfaceSupMin;
        
        if (!avecGicleurs) {
            pourcentageSurfaceMin = tableauUtilise[surfaceInferieure][rapportLH][distanceIndex];
            pourcentageSurfaceSupMin = tableauUtilise[Math.min(...facadeSurfaces.filter(s => s > surfaceInferieure))][rapportLH][distanceIndex];
        } else {
            pourcentageSurfaceMin = tableauUtilise[surfaceInferieure][distanceIndex];
            pourcentageSurfaceSupMin = tableauUtilise[Math.min(...facadeSurfaces.filter(s => s > surfaceInferieure))][distanceIndex];
        }
        
        return extrapolerPourcentageSurface(
            pourcentageSurfaceMin,
            pourcentageSurfaceSupMin,
            surfaceInferieure,
            surfaceFacade
        );
    }
    
    let pourcentageSurfInf, pourcentageSurfSup;
    
    if (!avecGicleurs) {
        pourcentageSurfInf = tableauUtilise[surfaceInferieure][rapportLH][distanceIndex];
        pourcentageSurfSup = tableauUtilise[surfaceSuperieure][rapportLH][distanceIndex];
    } else {
        pourcentageSurfInf = tableauUtilise[surfaceInferieure][distanceIndex];
        pourcentageSurfSup = tableauUtilise[surfaceSuperieure][distanceIndex];
    }
    
    // Si les surfaces sont identiques, retourner directement la valeur
    if (surfaceInferieure === surfaceSuperieure) {
        return pourcentageSurfInf;
    }
    
    // Interpolation linéaire entre les surfaces - CORRIGÉE selon méthodologie
    return pourcentageSurfSup + 
        ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
        (pourcentageSurfInf - pourcentageSurfSup);
}

// Fonction pour l'interpolation quand seule la distance varie (surface unique)
function interpolationDistanceUniquement(tableauUtilise, distanceLimitative, distanceInferieure, 
                                       distanceSuperieure, surface, distanceInferieureIndex, 
                                       distanceSuperieureIndex, rapportLH, avecGicleurs) {
    // Cas spécial: extrapolation pour distance limitative entre 0 et 1.2m
    const extrapolationDistance = distanceLimitative > 0 && distanceLimitative < distanceSuperieure && distanceInferieure === 0;
    
    if (extrapolationDistance) {
        let pourcentageDistance0 = 0; // Toujours 0% quand DL=0
        let pourcentageDistanceMin;
        
        if (!avecGicleurs) {
            pourcentageDistanceMin = tableauUtilise[surface][rapportLH][distanceSuperieureIndex];
        } else {
            pourcentageDistanceMin = tableauUtilise[surface][distanceSuperieureIndex];
        }
        
        // Extrapolation entre 0 et la première distance non-nulle
        return extrapolerPourcentage(
            pourcentageDistance0,
            pourcentageDistanceMin,
            distanceSuperieure,
            distanceLimitative
        );
    }
    
    let pourcentageDistInf, pourcentageDistSup;
    
    if (!avecGicleurs) {
        pourcentageDistInf = tableauUtilise[surface][rapportLH][distanceInferieureIndex];
        pourcentageDistSup = tableauUtilise[surface][rapportLH][distanceSuperieureIndex];
    } else {
        pourcentageDistInf = tableauUtilise[surface][distanceInferieureIndex];
        pourcentageDistSup = tableauUtilise[surface][distanceSuperieureIndex];
    }
    
    // Si les distances sont identiques, retourner directement la valeur
    if (distanceInferieure === distanceSuperieure) {
        return pourcentageDistInf;
    }
    
    // Interpolation linéaire entre les distances - CORRIGÉE selon méthodologie
    return pourcentageDistInf + 
        ((distanceLimitative - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
        (pourcentageDistSup - pourcentageDistInf);
}

// Fonction pour le calcul selon 9.10.14.4 ou 9.10.15.4 - MODIFIÉE avec extrapolation
function calculerPourcentage910x(tableau, distanceLimitative, surfaceFacade, avecGicleurs, avecMajoration) {
    const distances = tableau.distances;
    
    // Vérifier si la distance limitative est supérieure à la plage du tableau
    if (distanceLimitative > distances[distances.length - 1]) {
        return 100; // 100% de baies non protégées autorisées
    }
    
    // Trouver les distances encadrantes
    const distancesEncadrantes = trouverValeurEncadrantes(distanceLimitative, distances);
    const distanceInferieure = distancesEncadrantes.inferieure;
    const distanceSuperieure = distancesEncadrantes.superieure;
    const distanceInferieureIndex = distances.indexOf(distanceInferieure);
    const distanceSuperieureIndex = distances.indexOf(distanceSuperieure);
    const extrapolationDistance = distancesEncadrantes.extrapolation;
    const distanceExacte = distancesEncadrantes.valeurExacte;
    
    // Déterminer les surfaces disponibles dans le tableau
    const surfacesDisponibles = Object.keys(tableau.surfaces).filter(s => s !== ">100").map(Number);
    
    // Trouver les surfaces encadrantes
    let surfaceInferieure, surfaceSuperieure;
    let keyInf, keySup;
    
    if (surfaceFacade <= surfacesDisponibles[0]) {
        // Cas spécial: extrapolation pour petites surfaces (< 30m²)
        if (surfaceFacade < surfacesDisponibles[0]) {
            surfaceInferieure = surfaceFacade;
            surfaceSuperieure = surfacesDisponibles[0];
            keyInf = "extrapolation";
            keySup = surfacesDisponibles[0].toString();
        } else {
            surfaceInferieure = surfaceSuperieure = surfacesDisponibles[0];
            keyInf = keySup = surfacesDisponibles[0].toString();
        }
    } else if (surfaceFacade > surfacesDisponibles[surfacesDisponibles.length - 1]) {
        surfaceInferieure = surfacesDisponibles[surfacesDisponibles.length - 1];
        surfaceSuperieure = Infinity;
        keyInf = surfacesDisponibles[surfacesDisponibles.length - 1].toString();
        keySup = ">100";
    } else {
        for (let i = 0; i < surfacesDisponibles.length - 1; i++) {
            if (surfaceFacade > surfacesDisponibles[i] && surfaceFacade <= surfacesDisponibles[i + 1]) {
                surfaceInferieure = surfacesDisponibles[i];
                surfaceSuperieure = surfacesDisponibles[i + 1];
                keyInf = surfaceInferieure.toString();
                keySup = surfaceSuperieure.toString();
                break;
            }
        }
    }
    
    // Cas spécial: extrapolation pour distance limitative entre 0 et 1.2m
    if (extrapolationDistance) {
        let pourcentageDistance0 = 0; // Toujours 0% quand DL=0
        let pourcentageDistanceMin;
        
        // Vérifier si on a aussi une extrapolation de surface
        if (keyInf === "extrapolation") {
            // Double extrapolation (distance et surface)
            
            // D'abord déterminer le pourcentage pour la surface minimale du tableau à la distance minimale
            const pourcentageDistMinSurfMin = tableau.surfaces[keySup][distanceSuperieureIndex];
            const pourcentageDistMinSurfSupMin = tableau.surfaces[Object.keys(tableau.surfaces)[1]][distanceSuperieureIndex];
            
            // Extrapolation pour surface plus petite (avec la plus petite distance non-nulle)
            pourcentageDistanceMin = extrapolerPourcentageSurface(
                pourcentageDistMinSurfMin,
                pourcentageDistMinSurfSupMin,
                surfaceSuperieure,
                surfaceFacade
            );
        } else if (keyInf === keySup) {
            // Extrapolation de distance uniquement (surface dans le tableau)
            pourcentageDistanceMin = tableau.surfaces[keyInf][distanceSuperieureIndex];
        } else {
            // Extrapolation de distance et interpolation de surface
            const pourcentageDistMinSurfInf = tableau.surfaces[keyInf][distanceSuperieureIndex];
            const pourcentageDistMinSurfSup = tableau.surfaces[keySup][distanceSuperieureIndex];
            
            // Interpolation entre les surfaces à la distance minimale
            pourcentageDistanceMin = pourcentageDistMinSurfSup + 
                ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
                (pourcentageDistMinSurfInf - pourcentageDistMinSurfSup);
        }
        
        // Extrapolation entre 0 et la première distance non-nulle
        let pourcentageFinal = extrapolerPourcentage(
            pourcentageDistance0,
            pourcentageDistanceMin,
            distanceSuperieure,
            distanceExacte
        );
        
        // Appliquer la majoration si nécessaire
        if (avecMajoration || avecGicleurs) {
            pourcentageFinal = Math.min(100, pourcentageFinal * 2);
        }
        
        return Math.max(0, Math.min(100, pourcentageFinal));
    }
    
    // Cas spécial: extrapolation pour petites surfaces (< 30m²)
    if (keyInf === "extrapolation") {
        const pourcentageDistInfSurfMin = tableau.surfaces[keySup][distanceInferieureIndex];
        const pourcentageDistInfSurfSupMin = tableau.surfaces[Object.keys(tableau.surfaces)[1]][distanceInferieureIndex];
        
        // Extrapolation pour surface plus petite
        let pourcentageFinal = extrapolerPourcentageSurface(
            pourcentageDistInfSurfMin,
            pourcentageDistInfSurfSupMin,
            surfaceSuperieure, // Surface min du tableau
            surfaceFacade
        );
        
        // Appliquer la majoration si nécessaire
        if (avecMajoration || avecGicleurs) {
            pourcentageFinal = Math.min(100, pourcentageFinal * 2);
        }
        
        return Math.max(0, Math.min(100, pourcentageFinal));
    }
    
    // ÉTAPE 1: Interpolation selon la DL inférieure - MODIFIÉE
    let pourcentageDistanceInferieure;
    
    if (keyInf === keySup) {
        pourcentageDistanceInferieure = tableau.surfaces[keyInf][distanceInferieureIndex];
    } else {
        const pourcentageDistInfSurfInf = tableau.surfaces[keyInf][distanceInferieureIndex];
        const pourcentageDistInfSurfSup = tableau.surfaces[keySup][distanceInferieureIndex];
        
        // Formule MODIFIÉE selon la méthodologie de référence
        pourcentageDistanceInferieure = pourcentageDistInfSurfSup + 
            ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageDistInfSurfInf - pourcentageDistInfSurfSup);
    }

    // Si les distances sont identiques, pas besoin d'interpolation complexe
    if (distanceInferieure === distanceSuperieure) {
        let resultat = pourcentageDistanceInferieure;
        
        // Appliquer la majoration si nécessaire (briques de verre, verre armé ou gicleurs)
        if (avecMajoration || avecGicleurs) {
            resultat = Math.min(100, resultat * 2);
        }
        
        return resultat;
    }
    
    // ÉTAPE 2: Interpolation selon la DL supérieure - MODIFIÉE
    let pourcentageDistanceSuperieure;
    
    if (keyInf === keySup) {
        pourcentageDistanceSuperieure = tableau.surfaces[keyInf][distanceSuperieureIndex];
    } else {
        const pourcentageDistSupSurfInf = tableau.surfaces[keyInf][distanceSuperieureIndex];
        const pourcentageDistSupSurfSup = tableau.surfaces[keySup][distanceSuperieureIndex];
        
        // Formule MODIFIÉE selon la méthodologie de référence
        pourcentageDistanceSuperieure = pourcentageDistSupSurfSup + 
            ((surfaceFacade - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageDistSupSurfInf - pourcentageDistSupSurfSup);
    }
    
    // ÉTAPE 3: Interpolation finale entre les deux résultats d'interpolation précédents
    let pourcentageFinal = pourcentageDistanceInferieure + 
        ((distanceLimitative - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
        (pourcentageDistanceSuperieure - pourcentageDistanceInferieure);
    
    // Appliquer la formule spéciale pour les grandes surfaces si la distance est >= 1.2 m
    if (surfaceFacade > surfacesDisponibles[surfacesDisponibles.length - 1] && distanceLimitative >= 1.2) {
        // Pour le tableau 9.10.14.4-A avec usage "habitation" ou pour 9.10.15.4
        if (!tableau.hasOwnProperty("usages") || tableau.usages === "habitation") {
            pourcentageFinal = Math.pow(distanceLimitative, 2);
        } else { // Pour le tableau 9.10.14.4-A avec usage "commercial"
            pourcentageFinal = 0.5 * Math.pow(distanceLimitative, 2);
        }
    }
    
    // Appliquer la majoration si nécessaire (briques de verre, verre armé ou gicleurs)
    if (avecMajoration || avecGicleurs) {
        pourcentageFinal = Math.min(100, pourcentageFinal * 2);
    }
    
    // Limiter le pourcentage final entre 0 et 100
    return Math.max(0, Math.min(100, pourcentageFinal));
}

// Fonction pour calculer le pourcentage de baies non protégées selon CNB
function calculerPourcentageCNB(usage, distanceLimitative, surfaceFacade, length, height, avecGicleurs, glassBrick) {
    // Déterminer le rapport L/H
    const rapportLH = determinerRapportLH(length, height);
    
    // Calculer le pourcentage de base
    let pourcentage = interpolationCNB(
        usage, 
        distanceLimitative, 
        surfaceFacade, 
        rapportLH, 
        avecGicleurs
    );
    
    // Appliquer la majoration pour briques de verre/verre armé si nécessaire
    if (glassBrick) {
        pourcentage = Math.min(100, pourcentage * 2);
    }
    
    return pourcentage;
}

// Version spécifique pour 9.10.14 - MODIFIÉE pour utiliser la fonction calculerPourcentage910x corrigée
function calculerPourcentage91014(usage, distanceLimitative, surfaceFacade, avecGicleurs, avecMajoration) {
    const tableau = {
        usages: usage,
        surfaces: tableau91014[usage].surfaces,
        distances: tableau91014[usage].distances
    };
    
    return calculerPourcentage910x(tableau, distanceLimitative, surfaceFacade, avecGicleurs, avecMajoration);
}

// Version spécifique pour 9.10.15 - MODIFIÉE pour utiliser la fonction calculerPourcentage910x corrigée
function calculerPourcentage91015(distanceLimitative, surfaceFacade, avecGicleurs, avecMajoration) {
    return calculerPourcentage910x(tableau91015, distanceLimitative, surfaceFacade, avecGicleurs, avecMajoration);
}

function calculateCNB() {
    const facadeSurface = parseFloat(document.getElementById('surface_cnb').value);
    const length = parseFloat(document.getElementById('length_cnb').value);
    const height = parseFloat(document.getElementById('height_cnb').value);
    let limitingDistance = parseFloat(document.getElementById('distance_cnb').value);
    const sprinklersOption = document.getElementById('sprinklers_cnb').value;
    const response = document.getElementById('response_cnb').checked;
    const usage = document.getElementById('usage_cnb').value;
    const constructionType = document.getElementById('construction_type_cnb').value;
    const revetementType = document.getElementById('revetement_type_cnb').value;
    const glassBrick = document.getElementById('glass_brick_cnb').checked;
    const exemptBuilding = document.getElementById('exempt_building_cnb').value;
    const proposedArea = parseFloat(document.getElementById('proposed_area_cnb').value);
    const checkSpacing = document.getElementById('check_spacing_cnb').checked;
    const horizontalSpacing = parseFloat(document.getElementById('horizontal_spacing_cnb').value);
    const verticalSpacing = parseFloat(document.getElementById('vertical_spacing_cnb').value);
    const checkSoffit = document.getElementById('check_soffit_cnb').checked;
    const soffit_distance = parseFloat(document.getElementById('soffit_distance_cnb').value);
    const soffit_protected = document.getElementById('soffit_protected_cnb').checked;
    
    // Vérification des entrées
    if (isNaN(facadeSurface) || isNaN(length) || isNaN(height) || isNaN(limitingDistance) || 
        facadeSurface <= 0 || length <= 0 || height <= 0 || limitingDistance < 0) {
        document.getElementById('cnb-result').innerHTML = "Erreur : Veuillez entrer des valeurs numériques valides.";
        return;
    }
    
    // Vérifier si le bâtiment est exempté
    if (exemptBuilding !== "none") {
        let exemptMessage = "";
        if (exemptBuilding === "parking" && limitingDistance >= 3) {
            exemptMessage = `
                <strong>Bâtiment exempté - Garage de stationnement à étages ouverts :</strong><br>
                Selon l'article 3.2.3.10. 1), les façades de rayonnement d'un garage de stationnement dont 
                tous les étages sont des étages ouverts peuvent comporter des baies non protégées sans 
                limitation de surface si la distance limitative est d'au moins 3 m.<br><br>
                <strong>Surface maximale des baies non protégées : 100%</strong>
            `;
        } else if (exemptBuilding === "street_level" && limitingDistance >= 9) {
            exemptMessage = `
                <strong>Bâtiment exempté - Façade donnant sur une rue :</strong><br>
                Selon l'article 3.2.3.10. 2), la partie de la façade de rayonnement donnant sur une rue peut 
                comporter, à l'étage qui se trouve au niveau de la rue, des baies non protégées sans 
                limitation de surface si la distance limitative est d'au moins 9 m.<br><br>
                <strong>Surface maximale des baies non protégées : 100%</strong>
            `;
        } else {
            exemptMessage = `
                <strong>Bâtiment exempté - Conditions non satisfaites :</strong><br>
                Le bâtiment que vous avez sélectionné pourrait être exempté, mais les conditions ne sont pas satisfaites.<br>
                ${exemptBuilding === "parking" ? 
                    "- Pour un garage de stationnement à étages ouverts, la distance limitative doit être d'au moins 3 m." : 
                    "- Pour une façade donnant sur une rue, la distance limitative doit être d'au moins 9 m."}
            `;
        }
        
        if (exemptMessage.includes("100%")) {
            document.getElementById('copy_cnb').style.display = 'inline-block';
            document.getElementById('cnb-result').innerHTML = exemptMessage;
            return;
        }
        // Si non exempté, on continue avec le calcul normal
    }

    // Ajustement pour le délai d'intervention
    if (response) {
        limitingDistance = limitingDistance / 2;
    }

    // Utiliser la nouvelle méthode de calcul CNB
    const avecGicleurs = sprinklersOption === "complete";
    let pourcentage = calculerPourcentageCNB(
        usage, 
        limitingDistance, 
        facadeSurface, 
        length, 
        height, 
        avecGicleurs, 
        glassBrick
    );
    
    // Ajouter les précisions concernant 3.1.7.2. 1) et 3.2.3.1. 9) lorsque la distance limitative est < 1,2 m
    let rayonnementInfo = "";
    if (limitingDistance < 1.2) {
        rayonnementInfo = `
            <br><strong>Note concernant le rayonnement thermique :</strong><br>
            Selon l'article 3.1.7.2. 1), la limite d'élévation de température sur la face non exposée d'une construction ne s'applique pas 
            à un mur extérieur ayant une distance limitative de 1,2 m ou plus, pourvu que le rayonnement émis par la face non exposée 
            soit pris en compte pour effectuer une correction conformément au paragraphe 3.2.3.1. 9).<br>
            <br>
            Selon le paragraphe 3.2.3.1. 9), si la température superficielle de la face non exposée d'un mur dépasse les valeurs établies 
            par les essais normalisés de résistance au feu, il faut tenir compte du rayonnement émis par la face non exposée du mur en 
            ajoutant une surface équivalente de baies non protégées.
        `;
    }
    
    // Calculer la surface maximale de baies non protégées
    const maxArea = (pourcentage / 100) * facadeSurface;
    
    // Déterminer les exigences de construction selon 3.2.3.7
    let constructionRequirements = determineConstructionRequirements(pourcentage, usage, constructionType, revetementType);
    
    // Vérification de l'espacement des baies
    let spacingResult = "";
    if (checkSpacing) {
        const minHorizontalSpacing = 2.0; // En mètres selon 3.2.3.1.(6)
        const minVerticalSpacing = 2.0;   // En mètres selon 3.2.3.1.(6)
        
        if (horizontalSpacing < minHorizontalSpacing || verticalSpacing < minVerticalSpacing) {
            spacingResult = `
                <br><strong>Vérification de l'espacement des baies :</strong><br>
                ⚠️ <span style="color: red;">NON CONFORME</span> - L'espacement des baies ne respecte pas les exigences minimales.<br>
                Selon l'article 3.2.3.1.(6), l'espacement des baies non protégées desservant une même pièce doit être d'au moins :<br>
                - 2 m horizontalement (valeur saisie: ${horizontalSpacing} m)<br>
                - 2 m verticalement (valeur saisie: ${verticalSpacing} m)
            `;
        } else {
            spacingResult = `
                <br><strong>Vérification de l'espacement des baies :</strong><br>
                <span style="color: green;">CONFORME</span> - L'espacement des baies respecte les exigences minimales.<br>
                Espacement horizontal: ${horizontalSpacing} m (minimum requis: 2 m)<br>
                Espacement vertical: ${verticalSpacing} m (minimum requis: 2 m)
            `;
        }
    }
    
    // Vérification de la protection des soffites
    let soffitResult = "";
    if (checkSoffit) {
        if (soffit_distance < 0.45) {
            soffitResult = `
                <br><strong>Protection des soffites :</strong><br>
                Selon l'article 3.2.3.6.(2), aucun soffite ne doit faire saillie au-dessus de la façade de rayonnement
                lorsque la distance limitative est inférieure à 0,45 m.<br>
                ${soffit_distance < 0.45 ? 
                    "⚠️ <span style=\"color: red;\">La distance du soffite (" + soffit_distance + " m) est inférieure à 0,45 m. Aucun soffite n'est autorisé.</span>" : 
                    "La distance du soffite est conforme."}
            `;
        } else if (soffit_distance < 1.2) {
            soffitResult = `
                <br><strong>Protection des soffites :</strong><br>
                Selon l'article 3.2.3.6.(3-5), si la distance limitative est entre 0,45 m et 1,2 m, les soffites de toit 
                ne doivent pas faire saillie à moins de 0,45 m de la limite de propriété, ou doivent être protégés.<br>
                ${soffit_distance < 0.45 ? 
                    "⚠️ <span style=\"color: red;\">La distance du soffite (" + soffit_distance + " m) est inférieure à 0,45 m. Une protection est requise.</span>" : 
                    "La distance du soffite est d'au moins 0,45 m."}
                ${!soffit_protected && soffit_distance < 0.45 ? 
                    "<br>⚠️ <span style=\"color: green;\">Le soffite est protégé selon les exigences.</span>" : ""}
            `;
        } else {
            soffitResult = `
                <br><strong>Protection des soffites :</strong><br>
                <span style="color: green;">La distance du soffite (${soffit_distance} m) est supérieure à 1,2 m. 
                Aucune protection spécifique n'est requise.</span>
            `;
        }
    }

    // Ajouter une mention spéciale si on a fait une extrapolation
    let extrapolationInfo = "";
    if (facadeSurface < 10 || (limitingDistance > 0 && limitingDistance < 1.2)) {
        extrapolationInfo = `
            <br><strong>Remarque sur le calcul :</strong><br>
            ${facadeSurface < 10 ? "La surface de la façade de rayonnement (" + facadeSurface.toFixed(2) + " m²) est inférieure à la valeur minimale du tableau de référence (10 m²).<br>" : ""}
            ${limitingDistance > 0 && limitingDistance < 1.2 ? "La distance limitative (" + limitingDistance.toFixed(2) + " m) est inférieure à la valeur minimale non-nulle du tableau de référence (1,2 m).<br>" : ""}
            Une extrapolation a été effectuée pour obtenir un résultat plus précis.
        `;
    }

   // Afficher les résultats détaillés avec les calculs intermédiaires
   let resultHTML = `
   <strong>Données de calcul :</strong><br>
   ${response ? "Distance limitative ajustée : " + limitingDistance.toFixed(2) + " m<br>" : ""}
   Rapport L/H ou H/L : ${determinerRapportLH(length, height)}<br>
   Type de construction : ${constructionType}<br>
   Type de revêtement : ${revetementType}<br>
   Protection par gicleurs : ${sprinklersOption === "complete" ? "Complète" : sprinklersOption === "partial" ? "Partielle" : "Aucune"}<br>
   ${glassBrick ? "Majoration pour briques de verre/verre armé appliquée (x2)<br>" : ""}
   
   <br><strong>Résultats :</strong><br>
   Pourcentage maximal de baies non protégées : ${pourcentage.toFixed(2)}%<br>
   Surface maximale de baies non protégées : ${maxArea.toFixed(2)} m²
   ${constructionRequirements}
   ${extrapolationInfo}
   ${rayonnementInfo}
   ${spacingResult}
   ${soffitResult}
`;

    // Ajouter la comparaison avec la surface proposée
    if (!isNaN(proposedArea) && proposedArea > 0) {
        const proposedPercentage = (proposedArea / facadeSurface) * 100;
        let statusClass = "";
        let comparisonResult = "";
        
        if (proposedPercentage > pourcentage) {
            statusClass = "color: red; font-weight: bold;";
            comparisonResult = `
                <br><br><strong>Comparaison avec la surface proposée:</strong><br>
                Votre proposition: ${proposedArea.toFixed(2)} m² (${proposedPercentage.toFixed(2)}% de la façade)<br>
                <span style="${statusClass}">⚠️ La surface proposée dépasse le maximum autorisé de ${maxArea.toFixed(2)} m² (${pourcentage.toFixed(2)}%).</span>
            `;
        } else {
            statusClass = "color: green; font-weight: bold;";
            comparisonResult = `
                <br><br><strong>Comparaison avec la surface proposée:</strong><br>
                Votre proposition: ${proposedArea.toFixed(2)} m² (${proposedPercentage.toFixed(2)}% de la façade)<br>
                <span style="${statusClass}">La surface proposée respecte le maximum autorisé de ${maxArea.toFixed(2)} m² (${pourcentage.toFixed(2)}%).</span>
            `;
        }
        
        // Ajouter le résultat de comparaison à resultHTML
        resultHTML += comparisonResult;
    }
    
    // Ajouter le message de dégagement de responsabilité
    resultHTML += `
    <br><br><div style="font-style: italic; padding: 10px; border-top: 1px solid #ccc; margin-top: 10px;">
    <strong>Avis de non-responsabilité:</strong> Les résultats générés par cet outil sont fournis à titre indicatif uniquement. 
    L'utilisateur demeure responsable de valider leur conformité auprès d'un professionnel qualifié ou de l'autorité compétente en matière de sécurité incendie.
    </div>
`;           
    document.getElementById('cnb-result').innerHTML = resultHTML;
    document.getElementById('copy_cnb').style.display = 'inline-block';
}

function determineConstructionRequirements(percentage, usage, constructionType, revetementType) {
    // Déterminer le degré de résistance au feu et les exigences de construction selon 3.2.3.7
    let degre = "";
    let constructionExigence = "";
    let revetementExigence = "";
    
    if (percentage <= 10) {
        if (usage === "groupes_A_B3_C_D_F3") {
            degre = "1 h";
        } else { // groupes_E_F1_F2
            degre = "2 h";
        }
        constructionExigence = "Incombustible";
        revetementExigence = "Incombustible";
    } else if (percentage <= 25) {
        if (usage === "groupes_A_B3_C_D_F3") {
            degre = "1 h";
        } else { // groupes_E_F1_F2
            degre = "2 h";
        }
        constructionExigence = "Combustible ou incombustible";
        revetementExigence = "Incombustible";
     } else if (percentage <= 50) {
        if (usage === "groupes_A_B3_C_D_F3") {
            degre = "45 min";
        } else { // groupes_E_F1_F2
            degre = "1 h";
        }
        constructionExigence = "Combustible ou incombustible";
        revetementExigence = "Incombustible";
    } else if (percentage < 100) {
        if (usage === "groupes_A_B3_C_D_F3") {
            degre = "45 min";
        } else { // groupes_E_F1_F2
            degre = "1 h";
        }
        constructionExigence = "Combustible ou incombustible";
        revetementExigence = "Combustible ou incombustible";
    }
    
    // Si la construction actuelle n'est pas conforme, ajouter un avertissement
    let warningMsg = "";
    if ((constructionExigence === "Incombustible" && constructionType === "combustible") ||
        (revetementExigence === "Incombustible" && revetementType === "combustible")) {
        warningMsg = "<br>⚠️ <strong>Attention :</strong> La construction ou le revêtement sélectionné ne respecte pas les exigences minimales du tableau 3.2.3.7.";
    }
    
    return `
        <br><strong>Exigences de construction (tableau 3.2.3.7):</strong><br>
        Pour ${percentage.toFixed(2)}% de baies non protégées:<br>
        - Degré de résistance au feu minimal: ${degre}<br>
        - Type de construction exigé: ${constructionExigence}<br>
        - Type de revêtement exigé: ${revetementExigence}${warningMsg}
    `;
}

function calculate91014() {
    const usage = document.getElementById('usage_91014').value;
    const buildingType = document.getElementById('building_type_91014').value;
    const exteriorFinish = document.getElementById('exterior_finish_91014').value;
    const sprinklersOption = document.getElementById('sprinklers_91014').value;
    const glassBrick = document.getElementById('glass_brick_91014').checked;
    let limitingDistance = parseFloat(document.getElementById('distance_91014').value);
    const surface = parseFloat(document.getElementById('surface_91014').value);
    const response = document.getElementById('response_91014').checked;
    const proposedArea = parseFloat(document.getElementById('proposed_area_91014').value);
    let checkSpacing = document.getElementById('check_spacing_91014').checked;
    const horizontalSpacing = parseFloat(document.getElementById('horizontal_spacing_91014').value);
    const verticalSpacing = parseFloat(document.getElementById('vertical_spacing_91014').value);
    const checkSoffit = document.getElementById('check_soffit_91014').checked;
    const soffit_distance = parseFloat(document.getElementById('soffit_distance_91014').value);
    const soffit_protected = document.getElementById('soffit_protected_91014').checked;
    const distinction = document.getElementById('distinction_91014').value;

    // Vérification des entrées
    if (isNaN(limitingDistance) || isNaN(surface) || limitingDistance < 0 || surface <= 0) {
        document.getElementById('method91014-result').innerHTML = "Erreur : Veuillez entrer des valeurs numériques valides.";
        return;
    }

    // Ajustement pour le délai d'intervention
    if (response) {
        limitingDistance = limitingDistance / 2;
    }
    
    // Exemption pour les garages ou bâtiments secondaires
    if (buildingType === "garage") {
        // Selon 9.10.14.4.(10-12), les baies vitrées des garages peuvent être exemptées des restrictions
         document.getElementById('method91014-result').innerHTML = `
             <strong>Résultat pour garage ou bâtiment secondaire :</strong><br>
             Selon les paragraphes 9.10.14.4.(10-12) et 9.10.14.5.(4-5), les garages et bâtiments secondaires 
             qui ne desservent qu'un seul logement peuvent bénéficier d'exemptions importantes:<br><br>
             
             - Si le garage dessert un seul logement et est sur la même propriété: 
               <strong>pas de limite de surface pour les baies vitrées</strong><br>
             - Pour la construction de la façade de rayonnement, si la distance limitative est d'au moins 0,6 m:
               <strong>pas d'exigence quant au degré de résistance au feu</strong><br>
             - Si la distance limitative est inférieure à 0,6 m: <strong>un degré de résistance au feu d'au moins 
               45 min est requis</strong><br>
             - <strong>Aucune exigence quant au type de revêtement</strong>, peu importe la distance limitative<br><br>
             
             Pour une analyse plus spécifique, veuillez sélectionner "Bâtiment standard" dans le type de bâtiment.
         `;
         document.getElementById('copy_91014').style.display = 'inline-block';
         return;
     }

    // Si la distance limitative est d'au plus 2 m, activer automatiquement la vérification d'espacement
    if (limitingDistance <= 2.0) {
        // Activer la case à cocher et afficher les options d'espacement
        document.getElementById('check_spacing_91014').checked = true;
        document.getElementById('spacing_options_91014').style.display = 'block';
        checkSpacing = true; // S'assurer que la vérification sera effectuée
    }

    // Utiliser la nouvelle méthode de calcul 9.10.14
    const avecGicleurs = sprinklersOption === "complete";
    const pourcentage = calculerPourcentage91014(
        usage, 
        limitingDistance, 
        surface, 
        avecGicleurs, 
        glassBrick
    );
    
    // Calculer la surface maximale
    const maxArea = (pourcentage / 100) * surface;

    // Déterminer les exigences de construction et de protection
    let constructionRequirements = "";

    if (limitingDistance < 1.2) {
        constructionRequirements = `
            <br><strong>Exigences pour distance limitative < 1,2 m (9.10.14.4.2):</strong><br>
            - Les ouvertures doivent être protégées par des dispositifs d'obturation<br>
            - Le verre armé et les briques de verre ne sont pas autorisés<br>
            - ${exteriorFinish === "incombustible" ? 
                "Revêtement incombustible requis pour les façades" : 
                "Revêtement combustible soumis à des restrictions importantes (voir 9.10.14.5)"}
        `;
    }

    // Vérification de l'espacement des baies
    let spacingResult = "";
    if (checkSpacing) {
        const minHorizontalSpacing = 2.0; // En mètres selon 9.10.14.4.(4)
        const minVerticalSpacing = 2.0;   // En mètres selon 9.10.14.4.(4)
        
        if (limitingDistance <= 2.0) {
            // Calcul de la surface maximale de chaque baie selon 9.10.14.4.(3)
            let maxBaieArea = 0;
            let maxBaieInfo = "";
            let formulaArea = 0;
            
            if (limitingDistance < 1.2) {
                maxBaieArea = 0.35;
                maxBaieInfo = `Selon le tableau 9.10.14.4.-B, pour une distance limitative < 1,2 m, chaque baie ne doit pas dépasser 0,35 m².`;
            } else if (limitingDistance <= 1.5) {
                maxBaieArea = 0.78;
                formulaArea = Math.pow(limitingDistance, 2);
                
                if (formulaArea > maxBaieArea) {
                    maxBaieInfo = `Selon la formule du paragraphe 9.10.14.4.(3)b), chaque baie ne doit pas dépasser ${formulaArea.toFixed(2)} m² (méthode alternative selon le tableau 9.10.14.4.-B: ${maxBaieArea.toFixed(2)} m²).`;
                } else {
                    maxBaieInfo = `Selon le tableau 9.10.14.4.-B, chaque baie ne doit pas dépasser ${maxBaieArea.toFixed(2)} m² (méthode alternative selon la formule du paragraphe 9.10.14.4.(3)b): ${formulaArea.toFixed(2)} m²).`;
                }
            } else if (limitingDistance <= 2.0) {
                maxBaieArea = 1.88;
                formulaArea = Math.pow(limitingDistance, 2);
                
                if (formulaArea > maxBaieArea) {
                    maxBaieInfo = `Selon la formule du paragraphe 9.10.14.4.(3)b), chaque baie ne doit pas dépasser ${formulaArea.toFixed(2)} m² (méthode alternative selon le tableau 9.10.14.4.-B: ${maxBaieArea.toFixed(2)} m²).`;
                } else {
                    maxBaieInfo = `Selon le tableau 9.10.14.4.-B, chaque baie ne doit pas dépasser ${maxBaieArea.toFixed(2)} m² (méthode alternative selon la formule du paragraphe 9.10.14.4.(3)b): ${formulaArea.toFixed(2)} m²).`;
                }
            }
            
            spacingResult = `
                <br><strong>Vérification de l'espacement des baies :</strong><br>
                <strong>Restrictions selon 9.10.14.4.(3) :</strong><br>
                ${maxBaieInfo}<br>
            `;
            
            // Vérification de l'espacement
            if (horizontalSpacing < minHorizontalSpacing || verticalSpacing < minVerticalSpacing) {
                spacingResult += `
                    <strong>Espacement des baies :</strong><br>
                    ⚠️ <span style="color: red;">NON CONFORME</span> - L'espacement des baies ne respecte pas les exigences minimales.<br>
                    Selon l'article 9.10.14.4.(4), l'espacement des baies non protégées desservant une même pièce doit être d'au moins :<br>
                    - 2 m horizontalement (valeur saisie: ${horizontalSpacing} m)<br>
                    - 2 m verticalement (valeur saisie: ${verticalSpacing} m)
                `;
            } else {
                spacingResult += `
                    <strong>Espacement des baies :</strong><br>
                    <span style="color: green;">CONFORME</span> - L'espacement des baies respecte les exigences minimales.<br>
                    Espacement horizontal: ${horizontalSpacing} m (minimum requis: 2 m)<br>
                    Espacement vertical: ${verticalSpacing} m (minimum requis: 2 m)
                `;
            }
        } else {
            // Pour les distances > 2.0 m, indiquer que les restrictions ne s'appliquent pas
            spacingResult = `
                <br><strong>Vérification de l'espacement des baies :</strong><br>
                <span style="color: green;">NON APPLICABLE</span> - Les restrictions d'espacement et de taille des baies 
                prévues aux paragraphes 9.10.14.4.(3) et (4) ne s'appliquent que si la distance limitative est d'au plus 2 m.<br>
                Avec une distance limitative de ${limitingDistance.toFixed(2)} m > 2 m, ces restrictions ne s'appliquent pas.
            `;
        }
    }
     
     // Vérification de la protection des soffites
     let soffitResult = "";
     if (checkSoffit) {
         if (soffit_distance < 0.45) {
             soffitResult = `
                 <br><strong>Protection des soffites :</strong><br>
                 Selon l'article 9.10.14.5.(9), aucun soffite ne doit faire saillie au-dessus de la façade de rayonnement
                 lorsque la distance limitative est inférieure à 0,45 m.<br>
                 ${soffit_distance < 0.45 ? 
                     "⚠️ <span style=\"color: red;\">La distance du soffite (" + soffit_distance + " m) est inférieure à 0,45 m. Aucun soffite n'est autorisé.</span>" : 
                     "La distance du soffite est conforme."}
             `;
         } else if (soffit_distance < 1.2) {
             soffitResult = `
                 <br><strong>Protection des soffites :</strong><br>
                 Selon l'article 9.10.14.5.(10-12), si la distance limitative est entre 0,45 m et 1,2 m, les soffites de toit 
                 ne doivent pas faire saillie à moins de 0,45 m de la limite de propriété, ou doivent être protégés.<br>
                 ${soffit_distance < 0.45 ? 
                     "⚠️ <span style=\"color: red;\">La distance du soffite (" + soffit_distance + " m) est inférieure à 0,45 m. Une protection est requise.</span>" : 
                     "La distance du soffite est d'au moins 0,45 m."}
                 ${!soffit_protected && soffit_distance < 1.2 ? 
                     "<br>⚠️ <span style=\"color: red;\">Le soffite n'est pas protégé selon les exigences.</span>" : 
                     soffit_protected ? "<br><span style=\"color: green;\">Le soffite est protégé selon les exigences.</span>" : ""}
             `;
         } else {
             soffitResult = `
                 <br><strong>Protection des soffites :</strong><br>
                 <span style="color: green;">La distance du soffite (${soffit_distance} m) est supérieure à 1,2 m. 
                 Aucune protection spécifique n'est requise.</span>
             `;
         }
     }
     
     // Distinction entre baies vitrées et baies non protégées
     let distinctionInfo = "";
     if (distinction === "glazed") {
         distinctionInfo = `
             <br><strong>Type de baies :</strong><br>
             <i>Vous avez spécifié des baies vitrées. En vertu de 9.10.14, les baies vitrées sont une catégorie 
             spécifique de baies non protégées. Les baies vitrées sont soumises aux mêmes restrictions de 
             surface que les baies non protégées, mais peuvent avoir des exigences différentes en matière de 
             construction et de protection.</i>
         `;
     }

     // Ajouter une mention spéciale si on a fait une extrapolation
     let extrapolationInfo = "";
     if (surface < 30 || (limitingDistance > 0 && limitingDistance < 1.2)) {
         extrapolationInfo = `
             <br><strong>Remarque sur le calcul :</strong><br>
             ${surface < 30 ? "La surface de la façade de rayonnement (" + surface.toFixed(2) + " m²) est inférieure à la valeur minimale du tableau de référence (30 m²).<br>" : ""}
             ${limitingDistance > 0 && limitingDistance < 1.2 ? "La distance limitative (" + limitingDistance.toFixed(2) + " m) est inférieure à la valeur minimale non-nulle du tableau de référence (1,2 m).<br>" : ""}
             Une extrapolation a été effectuée pour obtenir un résultat plus précis.
         `;
     }

     // Afficher les résultats (la partie d'affichage reste la même)
     let resultHTML = `
          <strong>Données de calcul :</strong><br>
          ${response ? "Distance limitative ajustée : " + limitingDistance.toFixed(2) + " m<br>" : ""}
          Type d'usage : ${usage === "habitation" ? "Habitation, établissement d'affaires et établissement industriel à risques faibles" : "Établissement commercial et établissement industriel à risques moyens"}<br>
          Surface totale de la façade : ${surface.toFixed(2)} m²<br>
          Protection par gicleurs : ${sprinklersOption === "complete" ? "Complète" : sprinklersOption === "partial" ? "Partielle" : "Aucune"}<br>
          ${glassBrick ? "Majoration pour briques de verre/verre armé appliquée (x2)<br>" : ""}
          <br><strong>Résultats :</strong><br>
          Pourcentage maximal de baies non protégées : ${pourcentage.toFixed(2)}%<br>
          Surface maximale de baies non protégées : ${maxArea.toFixed(2)} m²
          ${constructionRequirements}
          ${extrapolationInfo}
          ${spacingResult}
          ${soffitResult}
          ${distinctionInfo}
      `;
     
     // Ajouter la comparaison avec la surface proposée si existe
     if (!isNaN(proposedArea) && proposedArea > 0) {
         const proposedPercentage = (proposedArea / surface) * 100;
         let statusClass = "";
         let comparisonResult = "";
         
         if (proposedPercentage > pourcentage) {
             statusClass = "color: red; font-weight: bold;";
             comparisonResult = `
                 <br><br><strong>Comparaison avec la surface proposée:</strong><br>
                 Votre proposition: ${proposedArea.toFixed(2)} m² (${proposedPercentage.toFixed(2)}% de la façade)<br>
                 <span style="${statusClass}">⚠️ La surface proposée dépasse le maximum autorisé de ${maxArea.toFixed(2)} m² (${pourcentage.toFixed(2)}%).</span>
             `;
         } else {
             statusClass = "color: green; font-weight: bold;";
             comparisonResult = `
                 <br><br><strong>Comparaison avec la surface proposée:</strong><br>
                 Votre proposition: ${proposedArea.toFixed(2)} m² (${proposedPercentage.toFixed(2)}% de la façade)<br>
                 <span style="${statusClass}">La surface proposée respecte le maximum autorisé de ${maxArea.toFixed(2)} m² (${pourcentage.toFixed(2)}%).</span>
             `;
         }
         
         // Ajouter le résultat de comparaison à resultHTML
         resultHTML += comparisonResult;
     }
     
     // Ajouter le message de dégagement de responsabilité
     resultHTML += `
     <br><br><div style="font-style: italic; padding: 10px; border-top: 1px solid #ccc; margin-top: 10px;">
     <strong>Avis de non-responsabilité:</strong> Les résultats générés par cet outil sont fournis à titre indicatif uniquement. 
     L'utilisateur demeure responsable de valider leur conformité auprès d'un professionnel qualifié ou de l'autorité compétente en matière de sécurité incendie.
     </div>
`;           
     document.getElementById('method91014-result').innerHTML = resultHTML;
     document.getElementById('copy_91014').style.display = 'inline-block';
}

function calculate91015() {
    const sprinklersOption = document.getElementById('sprinklers_91015').value;
    const glassBrick = document.getElementById('glass_brick_91015').checked;
    let limitingDistance = parseFloat(document.getElementById('distance_91015').value);
    const surface = parseFloat(document.getElementById('surface_91015').value);
    const response = document.getElementById('response_91015').checked;
    const housingType = document.getElementById('housing_type_91015').value;
    const revetingType = document.getElementById('reveting_type_91015').value;
    const proposedArea = parseFloat(document.getElementById('proposed_area_91015').value);
    const checkSpacing = document.getElementById('check_spacing_91015').checked;
    const horizontalSpacing = parseFloat(document.getElementById('horizontal_spacing_91015').value);
    const verticalSpacing = parseFloat(document.getElementById('vertical_spacing_91015').value);
    const checkSoffit = document.getElementById('check_soffit_91015').checked;
    const soffit_distance = parseFloat(document.getElementById('soffit_distance_91015').value);
    const soffit_protected = document.getElementById('soffit_protected_91015').checked;
    const distinction = document.getElementById('distinction_91015').value;

    // Vérification des entrées
    if (isNaN(limitingDistance) || isNaN(surface) || limitingDistance < 0 || surface <= 0) {
        document.getElementById('method91015-result').innerHTML = "Erreur : Veuillez entrer des valeurs numériques valides.";
        return;
    }

    // Ajustement pour le délai d'intervention
    if (response) {
        limitingDistance = limitingDistance / 2;
    }

    // Utiliser la nouvelle méthode de calcul 9.10.15
    const avecGicleurs = sprinklersOption === "complete";
    const pourcentage = calculerPourcentage91015(
        limitingDistance, 
        surface, 
        avecGicleurs, 
        glassBrick
    );
    
    // Calculer la surface maximale
    const maxArea = (pourcentage / 100) * surface;
    
    // Déterminer les exigences de construction
    let constructionRequirements = "";
    if (limitingDistance < 0.6) {
        constructionRequirements = `
            <br><strong>Exigences de construction (selon 9.10.15.5):</strong><br>
            - Degré de résistance au feu d'au moins 45 min pour la façade de rayonnement<br>
            - Revêtement extérieur ${revetingType === "incombustible" ? "incombustible" : "combustible avec contraintes"}<br>
            ${revetingType === "combustible" ? 
            `- Le revêtement combustible doit être installé selon l'article 9.10.15.5, paragraphe 2):<br>
               &nbsp;&nbsp;• Posé sur revêtement en plaques de plâtre d'au moins 12,7 mm ou maçonnerie<br>
               &nbsp;&nbsp;• Doit avoir un indice de propagation de la flamme d'au plus 25<br>
               &nbsp;&nbsp;• Si c'est un revêtement conforme à 9.27.12, son épaisseur ne doit pas dépasser 2 mm<br>
               &nbsp;&nbsp;• Peut aussi être conforme à l'alinéa 3.1.5.5.1)b)`
             : ""}
        `;
    } else if (limitingDistance < 1.2) {
        constructionRequirements = `
            <br><strong>Exigences de construction (selon 9.10.15.5):</strong><br>
            - Degré de résistance au feu d'au moins 45 min pour la façade de rayonnement<br>
            ${revetingType === "combustible" ? 
            `- Revêtement combustible soumis aux exigences du paragraphe 3) de l'article 9.10.15.5:<br>
               &nbsp;&nbsp;• Si conforme à 9.27.6, 9.27.7, 9.27.8, 9.27.9 ou 9.27.10:<br>
               &nbsp;&nbsp;&nbsp;&nbsp;- Posé sur revêtement en plaques de plâtre d'au moins 12,7 mm ou maçonnerie<br>
               &nbsp;&nbsp;&nbsp;&nbsp;- Doit avoir un indice de propagation de la flamme d'au plus 25 après conditionnement<br>
               &nbsp;&nbsp;• Si conforme à 9.27.12:<br>
               &nbsp;&nbsp;&nbsp;&nbsp;- Posé sur revêtement en plaques de plâtre d'au moins 12,7 mm ou maçonnerie<br>
               &nbsp;&nbsp;&nbsp;&nbsp;- Doit avoir un indice de propagation de la flamme d'au plus 25<br>
               &nbsp;&nbsp;&nbsp;&nbsp;- Ne doit pas dépasser 2 mm d'épaisseur<br>
               &nbsp;&nbsp;• Peut aussi être conforme à l'alinéa 3.1.5.5.1)b)`
             : "- Revêtement incombustible selon la section 9.20, la sous-section 9.27.11 ou la section 9.28"}
        `;
    } else {
        constructionRequirements = `
            <br><strong>Exigences de construction (selon 9.10.15.5):</strong><br>
            - Pour distance limitative ≥ 1,2 m: les restrictions sont moins sévères<br>
            - Les exigences minimales pour les soffites s'appliquent quand ils font saillie à moins de 1,2 m de la limite de propriété<br>
            - Pour les poteaux en gros bois d'œuvre: pas de conformité nécessaire si distance ≥ 3 m
        `;
    }
    
    // Vérification de l'espacement des baies
    let spacingResult = "";
    if (checkSpacing) {
        const minHorizontalSpacing = 2.0; // En mètres selon 9.10.15.4.(4)
        const minVerticalSpacing = 2.0;   // En mètres selon 9.10.15.4.(4)
        
        if (limitingDistance <= 2.0) {
            if (horizontalSpacing < minHorizontalSpacing || verticalSpacing < minVerticalSpacing) {
                spacingResult = `
                    <br><strong>Vérification de l'espacement des baies :</strong><br>
                    ⚠️ <span style="color: red;">NON CONFORME</span> - L'espacement des baies ne respecte pas les exigences minimales.<br>
                    Selon l'article 9.10.15.4.(4), l'espacement des baies vitrées desservant une même pièce doit être d'au moins :<br>
                    - 2 m horizontalement (valeur saisie: ${horizontalSpacing} m)<br>
                    - 2 m verticalement (valeur saisie: ${verticalSpacing} m)
                `;
            } else {
                spacingResult = `
                    <br><strong>Vérification de l'espacement des baies :</strong><br>
                    <span style="color: green;">CONFORME</span> - L'espacement des baies respecte les exigences minimales.<br>
                    Espacement horizontal: ${horizontalSpacing} m (minimum requis: 2 m)<br>
                    Espacement vertical: ${verticalSpacing} m (minimum requis: 2 m)
                `;
            }
        } else {
            // Pour les distances > 2.0 m, indiquer que les restrictions ne s'appliquent pas
            spacingResult = `
                <br><strong>Vérification de l'espacement des baies :</strong><br>
                <span style="color: green;">NON APPLICABLE</span> - Les restrictions d'espacement et de taille des baies 
                prévues aux paragraphes 9.10.15.4.(3) et (4) ne s'appliquent que si la distance limitative est d'au plus 2 m.<br>
                Avec une distance limitative de ${limitingDistance.toFixed(2)} m > 2 m, ces restrictions ne s'appliquent pas.
            `;
        }
    }
    
    // Vérification de la protection des soffites
    let soffitResult = "";
    if (checkSoffit) {
        if (soffit_distance < 0.45) {
            soffitResult = `
                <br><strong>Protection des soffites :</strong><br>
                Selon l'article 9.10.15.5.(8), aucun soffite ne doit faire saillie au-dessus de la façade de rayonnement
                lorsque la distance limitative est inférieure à 0,45 m.<br>
                ${soffit_distance < 0.45 ? 
                    "⚠️ <span style=\"color: red;\">La distance du soffite (" + soffit_distance + " m) est inférieure à 0,45 m. Aucun soffite n'est autorisé.</span>" : 
                    "La distance du soffite est conforme."}
            `;
        } else if (soffit_distance < 1.2) {
            soffitResult = `
                <br><strong>Protection des soffites :</strong><br>
                Selon l'article 9.10.15.5.(9-11), si la distance limitative est entre 0,45 m et 1,2 m, les soffites de toit 
                ne doivent pas faire saillie à moins de 0,45 m de la limite de propriété, ou doivent être protégés.<br>
                ${soffit_distance < 0.45 ? 
                    "⚠️ <span style=\"color: red;\">La distance du soffite (" + soffit_distance + " m) est inférieure à 0,45 m. Une protection est requise.</span>" : 
                    "La distance du soffite est d'au moins 0,45 m."}
                ${!soffit_protected && soffit_distance < 1.2 ? 
                    "<br>⚠️ <span style=\"color: red;\">Le soffite n'est pas protégé selon les exigences.</span>" : 
                    soffit_protected ? "<br><span style=\"color: green;\">Le soffite est protégé selon les exigences.</span>" : ""}
            `;
        } else {
            soffitResult = `
               <br><strong>Protection des soffites :</strong><br>
               <span style="color: green;">La distance du soffite (${soffit_distance} m) est supérieure à 1,2 m. 
               Aucune protection spécifique n'est requise.</span>
           `;
       }
   }
   
   // Ajouter des informations spécifiques au type d'habitation
   let housingInfo = "";
   if (housingType === "accessoire") {
       housingInfo = `
           <br><strong>Remarque pour logement accessoire:</strong><br>
           - Les maisons comportant un logement accessoire peuvent avoir des exigences supplémentaires.<br>
           - Vérifier également les exigences de l'article 9.10.15.5 pour les revêtements.<br>
       `;
   }
   
   // Distinction entre baies vitrées et baies non protégées
   let distinctionInfo = "";
   if (distinction === "glazed") {
       distinctionInfo = `
           <br><strong>Type de baies :</strong><br>
           <i>Vous avez spécifié des baies vitrées. La sous-section 9.10.15 fait spécifiquement référence 
           aux baies vitrées, qui sont une catégorie de baies non protégées. La distinction est importante 
           car certaines exigences peuvent varier.</i>
       `;
   }

   // Ajouter une mention spéciale si on a fait une extrapolation
   let extrapolationInfo = "";
   if (surface < 30 || (limitingDistance > 0 && limitingDistance < 1.2)) {
       extrapolationInfo = `
           <br><strong>Remarque sur le calcul :</strong><br>
           ${surface < 30 ? "La surface de la façade de rayonnement (" + surface.toFixed(2) + " m²) est inférieure à la valeur minimale du tableau de référence (30 m²).<br>" : ""}
           ${limitingDistance > 0 && limitingDistance < 1.2 ? "La distance limitative (" + limitingDistance.toFixed(2) + " m) est inférieure à la valeur minimale non-nulle du tableau de référence (1,2 m).<br>" : ""}
           Une extrapolation a été effectuée pour obtenir un résultat plus précis.
       `;
   }

   // Afficher les résultats (la partie d'affichage reste la même)
   let resultHTML = `
       <strong>Données de calcul :</strong><br>
       ${response ? "Distance limitative ajustée : " + limitingDistance.toFixed(2) + " m<br>" : ""}
       Surface totale de la façade : ${surface.toFixed(2)} m²<br>
       Type d'habitation : ${housingType === "standard" ? "Habitation standard" : "Maison comportant un logement accessoire"}<br>
       Type de revêtement : ${revetingType === "combustible" ? "Combustible" : "Incombustible"}<br>
       Protection par gicleurs : ${sprinklersOption === "complete" ? "Complète" : sprinklersOption === "partial" ? "Partielle" : "Aucune"}<br>
       ${glassBrick ? "Majoration pour briques de verre/verre armé appliquée (x2)<br>" : ""}
       <br><strong>Résultats :</strong><br>
       Pourcentage maximal de baies non protégées : ${pourcentage.toFixed(2)}%<br>
       Surface maximale de baies non protégées : ${maxArea.toFixed(2)} m²
       ${constructionRequirements}
       ${extrapolationInfo}
       ${spacingResult}
       ${soffitResult}
       ${housingInfo}
       ${distinctionInfo}
   `;

   // Ajouter la comparaison avec la surface proposée si existe
   if (!isNaN(proposedArea) && proposedArea > 0) {
       const proposedPercentage = (proposedArea / surface) * 100;
       let statusClass = "";
       let comparisonResult = "";
       
       if (proposedPercentage > pourcentage) {
           statusClass = "color: red; font-weight: bold;";
           comparisonResult = `
               <br><br><strong>Comparaison avec la surface proposée:</strong><br>
               Votre proposition: ${proposedArea.toFixed(2)} m² (${proposedPercentage.toFixed(2)}% de la façade)<br>
               <span style="${statusClass}">⚠️ La surface proposée dépasse le maximum autorisé de ${maxArea.toFixed(2)} m² (${pourcentage.toFixed(2)}%).</span>
           `;
       } else {
           statusClass = "color: green; font-weight: bold;";
           comparisonResult = `
               <br><br><strong>Comparaison avec la surface proposée:</strong><br>
               Votre proposition: ${proposedArea.toFixed(2)} m² (${proposedPercentage.toFixed(2)}% de la façade)<br>
               <span style="${statusClass}">La surface proposée respecte le maximum autorisé de ${maxArea.toFixed(2)} m² (${pourcentage.toFixed(2)}%).</span>
           `;
       }
       
       // Ajouter le résultat de comparaison à resultHTML
       resultHTML += comparisonResult;
   }
   
   // Ajouter le message de dégagement de responsabilité
   resultHTML += `
   <br><br><div style="font-style: italic; padding: 10px; border-top: 1px solid #ccc; margin-top: 10px;">
   <strong>Avis de non-responsabilité:</strong> Les résultats générés par cet outil sont fournis à titre indicatif uniquement. 
   L'utilisateur demeure responsable de valider leur conformité auprès d'un professionnel qualifié ou de l'autorité compétente en matière de sécurité incendie.
   </div>
`;
   
   document.getElementById('method91015-result').innerHTML = resultHTML;
   document.getElementById('copy_91015').style.display = 'inline-block';
}

function openTab(event, tabName) {
    var tabcontent = document.getElementsByClassName("tab-content");
    for (var i = 0; i < tabcontent.length; i++) {
        tabcontent[i].classList.remove("active");
    }
    var tablinks = document.getElementsByClassName("tab-link");
    for (var i = 0; i < tablinks.length; i++) {
        tablinks[i].classList.remove("active");
    }
    document.getElementById(tabName).classList.add("active");
    event.currentTarget.classList.add("active");
}

// Fonction pour formater les calculs d'interpolation pour CNB - MISE À JOUR pour inclure l'extrapolation
function formatCNBCalculationSteps() {
    const usage = document.getElementById('usage_cnb').value;
    const limitingDistance = parseFloat(document.getElementById('distance_cnb').value);
    const facadeSurface = parseFloat(document.getElementById('surface_cnb').value);
    const length = parseFloat(document.getElementById('length_cnb').value);
    const height = parseFloat(document.getElementById('height_cnb').value);
    const sprinklersOption = document.getElementById('sprinklers_cnb').value;
    const avecGicleurs = sprinklersOption === "complete";
    const glassBrick = document.getElementById('glass_brick_cnb').checked;
    const response = document.getElementById('response_cnb').checked;
    
    // Ajustement pour le délai d'intervention
    const adjustedDistance = response ? limitingDistance / 2 : limitingDistance;
    
    // Déterminer le rapport L/H
    const rapportLH = determinerRapportLH(length, height);
    
    // Déterminer les tableaux à utiliser
    let tableauUtilise, distancesUtilisees, surfacesUtilisees;
    
    if (avecGicleurs) {
        if (usage === "groupes_A_B3_C_D_F3") {
            tableauUtilise = tableauAvecGicleursGroupesABCDF3;
            distancesUtilisees = limitingDistancesWithSprinklersABCDF3;
            surfacesUtilisees = facadeSurfacesWithSprinklersABCDF3;
        } else {
            tableauUtilise = tableauAvecGicleursGroupesEF1F2;
            distancesUtilisees = limitingDistancesWithSprinklersEF1F2;
            surfacesUtilisees = facadeSurfacesWithSprinklersEF1F2;
        }
    } else {
        distancesUtilisees = limitingDistancesNoSprinklers;
        surfacesUtilisees = facadeSurfaces;
        if (usage === "groupes_A_B3_C_D_F3") {
            tableauUtilise = tableauGroupesAB3CDF3;
        } else {
            tableauUtilise = tableauGroupesEF1F2;
        }
    }
    
    // Préparer le texte formaté
    let output = "Selon les données du ";
    output += avecGicleurs ? 
        (usage === "groupes_A_B3_C_D_F3" ? "Tableau 3.2.3.1.-D" : "Tableau 3.2.3.1.-E") : 
        (usage === "groupes_A_B3_C_D_F3" ? "Tableau 3.2.3.1.-B" : "Tableau 3.2.3.1.-C");
    output += ":\n\n";
    
    // Paramètres
    output += "Paramètres indiqués:\n";
    output += `DL: ${adjustedDistance.toFixed(2)}m\n`;
    output += `Surface de la FDR: ${facadeSurface.toFixed(2)}m²\n`;
    output += `Proportion L/H : Largeur : ${length.toFixed(2)}m ; Hauteur : ${height.toFixed(2)}m\n`;
    output += `Le rapport L/H est ${rapportLH}\n\n`;
    
    // Vérifier si extrapolation nécessaire
    const extrapolationSurface = facadeSurface < surfacesUtilisees[0];
    const extrapolationDistance = adjustedDistance > 0 && adjustedDistance < distancesUtilisees.find(d => d > 0);
    
    if (extrapolationDistance && !extrapolationSurface) {
        // Cas d'extrapolation pour distance uniquement
        output += "Extrapolation pour distance limitative entre 0 et 1,2m:\n";
        output += `- À distance = 0m: pourcentage = 0% (toujours)\n`;
        
        let pourcentageDistanceMin;
        if (!avecGicleurs) {
            pourcentageDistanceMin = tableauUtilise[surfacesUtilisees[0]][rapportLH][1]; // Index 1 = 1.2m
            output += `- À distance = 1,2m: pourcentage = ${pourcentageDistanceMin}% (pour surface de ${surfacesUtilisees[0]}m²)\n`;
        } else {
            pourcentageDistanceMin = tableauUtilise[surfacesUtilisees[0]][1]; // Index 1 = 1.2m
            output += `- À distance = 1,2m: pourcentage = ${pourcentageDistanceMin}% (pour surface de ${surfacesUtilisees[0]}m²)\n`;
        }
        
        // Calculer l'extrapolation
        const pente = pourcentageDistanceMin / 1.2; // Pente = % à 1.2m divisé par 1.2
        const pourcentageExtrapole = pente * adjustedDistance;
        
        output += `Formule d'extrapolation linéaire: % = (${pourcentageDistanceMin} ÷ 1,2) × ${adjustedDistance.toFixed(2)} = ${pourcentageExtrapole.toFixed(2)}%\n\n`;
        
        if (glassBrick) {
            const pourcentageAvecMajoration = Math.min(100, pourcentageExtrapole * 2);
            output += `Avec majoration pour briques de verre/verre armé (×2): ${pourcentageAvecMajoration.toFixed(2)}%\n`;
        }
        
        return output;
    }
    
    if (extrapolationSurface && !extrapolationDistance) {
        // Cas d'extrapolation pour surface uniquement
        output += "Extrapolation pour surface de façade inférieure à 10m²:\n";
        
        let pourcentageSurfMin, pourcentageSurfSupMin;
        if (!avecGicleurs) {
            pourcentageSurfMin = tableauUtilise[surfacesUtilisees[0]][rapportLH][distancesUtilisees.indexOf(Math.max(...distancesUtilisees.filter(d => d <= adjustedDistance)))];
            pourcentageSurfSupMin = tableauUtilise[surfacesUtilisees[1]][rapportLH][distancesUtilisees.indexOf(Math.max(...distancesUtilisees.filter(d => d <= adjustedDistance)))];
            
            output += `- Pour surface = ${surfacesUtilisees[0]}m²: pourcentage = ${pourcentageSurfMin}%\n`;
            output += `- Pour surface = ${surfacesUtilisees[1]}m²: pourcentage = ${pourcentageSurfSupMin}%\n`;
        } else {
            pourcentageSurfMin = tableauUtilise[surfacesUtilisees[0]][distancesUtilisees.indexOf(Math.max(...distancesUtilisees.filter(d => d <= adjustedDistance)))];
            pourcentageSurfSupMin = tableauUtilise[surfacesUtilisees[1]][distancesUtilisees.indexOf(Math.max(...distancesUtilisees.filter(d => d <= adjustedDistance)))];
            
            output += `- Pour surface = ${surfacesUtilisees[0]}m²: pourcentage = ${pourcentageSurfMin}%\n`;
            output += `- Pour surface = ${surfacesUtilisees[1]}m²: pourcentage = ${pourcentageSurfSupMin}%\n`;
        }
        
        // Extrapolation - plus la surface est petite, plus le pourcentage permis est élevé
        const ratio = surfacesUtilisees[0] / facadeSurface;
        const facteur = Math.sqrt(ratio);
        const tendance = (pourcentageSurfMin - pourcentageSurfSupMin) * (facteur - 1);
        const pourcentageExtrapole = Math.min(100, pourcentageSurfMin + tendance);
        
        output += `Formule d'extrapolation pour surface plus petite: % = ${pourcentageSurfMin} + (${pourcentageSurfMin} - ${pourcentageSurfSupMin}) × (√(${surfacesUtilisees[0]} ÷ ${facadeSurface.toFixed(2)}) - 1)\n`;
        output += `% = ${pourcentageSurfMin} + ${tendance.toFixed(2)} = ${pourcentageExtrapole.toFixed(2)}%\n\n`;
        
        if (glassBrick) {
            const pourcentageAvecMajoration = Math.min(100, pourcentageExtrapole * 2);
            output += `Avec majoration pour briques de verre/verre armé (×2): ${pourcentageAvecMajoration.toFixed(2)}%\n`;
        }
        
        return output;
    }
    
    if (extrapolationSurface && extrapolationDistance) {
        // Cas de double extrapolation (surface et distance)
        output += "Double extrapolation (distance et surface):\n";
        output += "1) Extrapolation pour la plus petite surface du tableau (10m²) avec distance entre 0 et 1,2m:\n";
        output += `- À distance = 0m: pourcentage = 0% (toujours)\n`;
        
        let pourcentageDistMinSurfMin;
        if (!avecGicleurs) {
            pourcentageDistMinSurfMin = tableauUtilise[surfacesUtilisees[0]][rapportLH][1]; // Index 1 = 1.2m
            output += `- À distance = 1,2m: pourcentage = ${pourcentageDistMinSurfMin}% (pour surface de ${surfacesUtilisees[0]}m²)\n`;
        } else {
            pourcentageDistMinSurfMin = tableauUtilise[surfacesUtilisees[0]][1]; // Index 1 = 1.2m
            output += `- À distance = 1,2m: pourcentage = ${pourcentageDistMinSurfMin}% (pour surface de ${surfacesUtilisees[0]}m²)\n`;
        }
        
        // Extrapolation distance pour surface min
        const pente1 = pourcentageDistMinSurfMin / 1.2;
        const pourcentageEtape1 = pente1 * adjustedDistance;
        
        output += `Étape 1 - Extrapolation distance: % = (${pourcentageDistMinSurfMin} ÷ 1,2) × ${adjustedDistance.toFixed(2)} = ${pourcentageEtape1.toFixed(2)}%\n\n`;
        
        output += "2) Extrapolation pour la surface réelle à partir du résultat précédent:\n";
        
        let pourcentageSurfSupMin;
        if (!avecGicleurs) {
            pourcentageSurfSupMin = tableauUtilise[surfacesUtilisees[1]][rapportLH][1]; // 1.2m pour deuxième surface du tableau
            
            // Extrapolation distance pour surface sup min
            const pente2 = pourcentageSurfSupMin / 1.2;
            const pourcentageEtape1bis = pente2 * adjustedDistance;
            
            output += `- Pour surface = ${surfacesUtilisees[1]}m² à la distance ${adjustedDistance.toFixed(2)}m: % = ${pourcentageEtape1bis.toFixed(2)}%\n`;
        } else {
            pourcentageSurfSupMin = tableauUtilise[surfacesUtilisees[1]][1]; // 1.2m pour deuxième surface du tableau
            
            // Extrapolation distance pour surface sup min
            const pente2 = pourcentageSurfSupMin / 1.2;
            const pourcentageEtape1bis = pente2 * adjustedDistance;
            
            output += `- Pour surface = ${surfacesUtilisees[1]}m² à la distance ${adjustedDistance.toFixed(2)}m: % = ${pourcentageEtape1bis.toFixed(2)}%\n`;
        }
        
        // Extrapolation surface
        const ratio = surfacesUtilisees[0] / facadeSurface;
        const facteur = Math.sqrt(ratio);
        const pourcentageDistSupMin = (pourcentageSurfSupMin / 1.2) * adjustedDistance;
        const tendance = (pourcentageEtape1 - pourcentageDistSupMin) * (facteur - 1);
        const pourcentageExtrapole = Math.min(100, pourcentageEtape1 + tendance);
        
        output += `Étape 2 - Extrapolation surface: % = ${pourcentageEtape1.toFixed(2)} + (${pourcentageEtape1.toFixed(2)} - ${pourcentageDistSupMin.toFixed(2)}) × (√(${surfacesUtilisees[0]} ÷ ${facadeSurface.toFixed(2)}) - 1)\n`;
        output += `% = ${pourcentageEtape1.toFixed(2)} + ${tendance.toFixed(2)} = ${pourcentageExtrapole.toFixed(2)}%\n\n`;
        
        if (glassBrick) {
            const pourcentageAvecMajoration = Math.min(100, pourcentageExtrapole * 2);
            output += `Avec majoration pour briques de verre/verre armé (×2): ${pourcentageAvecMajoration.toFixed(2)}%\n`;
        }
        
        return output;
    }
    
    // Si c'est une valeur exacte dans le tableau, pas besoin d'interpoler
    // Trouver les bornes d'encadrement
    const distancesEncadrantes = trouverValeurEncadrantes(adjustedDistance, distancesUtilisees);
    const distanceInferieure = distancesEncadrantes.inferieure;
    const distanceSuperieure = distancesEncadrantes.superieure;
    const distanceInferieureIndex = distancesUtilisees.indexOf(distanceInferieure);
    const distanceSuperieureIndex = distancesUtilisees.indexOf(distanceSuperieure);
    
    const surfacesEncadrantes = trouverValeurEncadrantes(facadeSurface, surfacesUtilisees);
    const surfaceInferieure = surfacesEncadrantes.inferieure;
    const surfaceSuperieure = surfacesEncadrantes.superieure;
    
    if (distanceInferieure === distanceSuperieure && surfaceInferieure === surfaceSuperieure) {
        let pourcentageFinal;
        if (!avecGicleurs) {
            pourcentageFinal = tableauUtilise[surfaceInferieure][rapportLH][distanceInferieureIndex];
        } else {
            pourcentageFinal = tableauUtilise[surfaceInferieure][distanceInferieureIndex];
        }
        
        output += `Valeur exacte trouvée dans le tableau: ${pourcentageFinal}%\n`;
        if (glassBrick) {
            output += `Avec majoration pour briques de verre/verre armé (x2): ${Math.min(100, pourcentageFinal * 2)}%\n`;
        }
        return output;
    }
    
    // Étape 1: Interpolation selon DL inférieure
    let pourcentageDistanceInferieure;
    output += "Étape 1: Interpolation selon la DL encadrante inférieure (" + distanceInferieure + "m):\n";
    
    if (!avecGicleurs) {
        const pourcentageSurfInfDistInf = tableauUtilise[surfaceInferieure][rapportLH][distanceInferieureIndex];
        const pourcentageSurfSupDistInf = tableauUtilise[surfaceSuperieure][rapportLH][distanceInferieureIndex];
        
        output += `À DL de ${distanceInferieure}m et surface max. de ${surfaceInferieure}m²: ${pourcentageSurfInfDistInf}%\n`;
        output += `À DL de ${distanceInferieure}m et surface max. de ${surfaceSuperieure}m²: ${pourcentageSurfSupDistInf}%\n`;
        
        pourcentageDistanceInferieure = pourcentageSurfSupDistInf + 
            ((facadeSurface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistInf - pourcentageSurfSupDistInf);
        
        output += `${pourcentageSurfSupDistInf} + (${facadeSurface.toFixed(2)} – ${surfaceInferieure}) / (${surfaceSuperieure} – ${surfaceInferieure}) x (${pourcentageSurfInfDistInf} – ${pourcentageSurfSupDistInf}) = `;
        output += `${pourcentageSurfSupDistInf} + ${((facadeSurface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure) * (pourcentageSurfInfDistInf - pourcentageSurfSupDistInf)).toFixed(2)} = ${pourcentageDistanceInferieure.toFixed(2)} %\n\n`;
    } else {
        const pourcentageSurfInfDistInf = tableauUtilise[surfaceInferieure][distanceInferieureIndex];
        const pourcentageSurfSupDistInf = tableauUtilise[surfaceSuperieure][distanceInferieureIndex];
        
        output += `À DL de ${distanceInferieure}m et surface max. de ${surfaceInferieure}m²: ${pourcentageSurfInfDistInf}%\n`;
        output += `À DL de ${distanceInferieure}m et surface max. de ${surfaceSuperieure}m²: ${pourcentageSurfSupDistInf}%\n`;
        
        pourcentageDistanceInferieure = pourcentageSurfSupDistInf + 
            ((facadeSurface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistInf - pourcentageSurfSupDistInf);
        
        output += `${pourcentageSurfSupDistInf} + (${facadeSurface.toFixed(2)} – ${surfaceInferieure}) / (${surfaceSuperieure} – ${surfaceInferieure}) x (${pourcentageSurfInfDistInf} – ${pourcentageSurfSupDistInf}) = `;
        output += `${pourcentageSurfSupDistInf} + ${((facadeSurface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure) * (pourcentageSurfInfDistInf - pourcentageSurfSupDistInf)).toFixed(2)} = ${pourcentageDistanceInferieure.toFixed(2)} %\n\n`;
    }
    
    // Si les distances sont identiques, pas besoin d'interpolation supplémentaire
    if (distanceInferieure === distanceSuperieure) {
        if (glassBrick) {
            output += `Résultat final: ${pourcentageDistanceInferieure.toFixed(2)}%\n`;
            output += `Avec majoration pour briques de verre/verre armé (x2): ${Math.min(100, pourcentageDistanceInferieure * 2).toFixed(2)}%\n`;
        } else {
            output += `Résultat final: ${pourcentageDistanceInferieure.toFixed(2)}%\n`;
        }
        return output;
    }
    
    // Étape 2: Interpolation selon DL supérieure
    let pourcentageDistanceSuperieure;
    output += "Étape 2: Interpolation selon la DL encadrante supérieure (" + distanceSuperieure + "m):\n";
    
    if (!avecGicleurs) {
        const pourcentageSurfInfDistSup = tableauUtilise[surfaceInferieure][rapportLH][distanceSuperieureIndex];
        const pourcentageSurfSupDistSup = tableauUtilise[surfaceSuperieure][rapportLH][distanceSuperieureIndex];
        
        output += `À DL de ${distanceSuperieure}m et surface max. de ${surfaceInferieure}m²: ${pourcentageSurfInfDistSup}%\n`;
        output += `À DL de ${distanceSuperieure}m et surface max. de ${surfaceSuperieure}m²: ${pourcentageSurfSupDistSup}%\n`;
        
        pourcentageDistanceSuperieure = pourcentageSurfSupDistSup + 
            ((facadeSurface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistSup - pourcentageSurfSupDistSup);
        
        output += `${pourcentageSurfSupDistSup} + (${facadeSurface.toFixed(2)} – ${surfaceInferieure}) / (${surfaceSuperieure} – ${surfaceInferieure}) x (${pourcentageSurfInfDistSup} – ${pourcentageSurfSupDistSup}) = `;
        output += `${pourcentageSurfSupDistSup} + ${((facadeSurface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure) * (pourcentageSurfInfDistSup - pourcentageSurfSupDistSup)).toFixed(2)} = ${pourcentageDistanceSuperieure.toFixed(2)} %\n\n`;
    } else {
        const pourcentageSurfInfDistSup = tableauUtilise[surfaceInferieure][distanceSuperieureIndex];
        const pourcentageSurfSupDistSup = tableauUtilise[surfaceSuperieure][distanceSuperieureIndex];
        
        output += `À DL de ${distanceSuperieure}m et surface max. de ${surfaceInferieure}m²: ${pourcentageSurfInfDistSup}%\n`;
        output += `À DL de ${distanceSuperieure}m et surface max. de ${surfaceSuperieure}m²: ${pourcentageSurfSupDistSup}%\n`;
        
        pourcentageDistanceSuperieure = pourcentageSurfSupDistSup + 
            ((facadeSurface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageSurfInfDistSup - pourcentageSurfSupDistSup);
        
        output += `${pourcentageSurfSupDistSup} + (${facadeSurface.toFixed(2)} – ${surfaceInferieure}) / (${surfaceSuperieure} – ${surfaceInferieure}) x (${pourcentageSurfInfDistSup} – ${pourcentageSurfSupDistSup}) = `;
        output += `${pourcentageSurfSupDistSup} + ${((facadeSurface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure) * (pourcentageSurfInfDistSup - pourcentageSurfSupDistSup)).toFixed(2)} = ${pourcentageDistanceSuperieure.toFixed(2)} %\n\n`;
    }
    
    // Étape 3: Interpolation finale
    output += "Étape 3: Interpolation selon les résultats obtenus des deux interpolations précédentes:\n";
    
    const pourcentageFinal = pourcentageDistanceInferieure + 
        ((adjustedDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
        (pourcentageDistanceSuperieure - pourcentageDistanceInferieure);
    
    output += `${pourcentageDistanceInferieure.toFixed(2)} + (${adjustedDistance.toFixed(2)} – ${distanceInferieure}) / (${distanceSuperieure} – ${distanceInferieure}) x (${pourcentageDistanceSuperieure.toFixed(2)} – ${pourcentageDistanceInferieure.toFixed(2)}) = `;
    output += `${pourcentageDistanceInferieure.toFixed(2)} + ${((adjustedDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure) * (pourcentageDistanceSuperieure - pourcentageDistanceInferieure)).toFixed(2)} = ${pourcentageFinal.toFixed(2)} %\n`;
    
    // Appliquer la majoration pour briques de verre/verre armé si nécessaire
    if (glassBrick) {
        const pourcentageFinalAvecMajoration = Math.min(100, pourcentageFinal * 2);
        output += `\nAvec majoration pour briques de verre/verre armé (x2): ${pourcentageFinalAvecMajoration.toFixed(2)}%\n`;
    }
    
    return output;
}

// Fonction pour formater les calculs d'interpolation pour 9.10.14 - MISE À JOUR pour inclure l'extrapolation
function format91014CalculationSteps() {
    const usage = document.getElementById('usage_91014').value;
    const buildingType = document.getElementById('building_type_91014').value;
    let limitingDistance = parseFloat(document.getElementById('distance_91014').value);
    const surface = parseFloat(document.getElementById('surface_91014').value);
    const sprinklersOption = document.getElementById('sprinklers_91014').value;
    const avecGicleurs = sprinklersOption === "complete";
    const glassBrick = document.getElementById('glass_brick_91014').checked;
    const response = document.getElementById('response_91014').checked;
    
    // Si c'est un garage, ajouter une note spéciale
    if (buildingType === "garage") {
        return "Selon les paragraphes 9.10.14.4.(10-12) et 9.10.14.5.(4-5), les garages et bâtiments secondaires " +
               "qui ne desservent qu'un seul logement peuvent bénéficier d'exemptions importantes pour les baies vitrées " +
               "et les exigences de construction.";
    }
    
    // Ajustement pour le délai d'intervention
    const adjustedDistance = response ? limitingDistance / 2 : limitingDistance;
    
    // Récupérer le tableau approprié
    const tableau = {
        surfaces: tableau91014[usage].surfaces,
        distances: tableau91014[usage].distances
    };
    
    // Préparer le texte formaté
    let output = "Selon les données du Tableau 9.10.14.4.-A:\n\n";
    
    // Paramètres
    output += "Paramètres indiqués:\n";
    output += `DL: ${adjustedDistance.toFixed(2)}m\n`;
    output += `Surface de la FDR: ${surface.toFixed(2)}m²\n\n`;
    
    // Vérifier si extrapolation nécessaire
    const surfacesDisponibles = Object.keys(tableau.surfaces).filter(s => s !== ">100").map(Number);
    const extrapolationSurface = surface < surfacesDisponibles[0];
    const extrapolationDistance = adjustedDistance > 0 && adjustedDistance < tableau.distances.find(d => d > 0);
    
    // Cas particulier: Formule du carré de la distance
    if (surface > surfacesDisponibles[surfacesDisponibles.length - 1] && adjustedDistance >= 1.2) {
        if (usage === "habitation") {
            output += `Surface > ${surfacesDisponibles[surfacesDisponibles.length - 1]}m² et DL ≥ 1,2m: formule du carré de la distance:\n`;
            output += `Pourcentage = (DL)² = (${adjustedDistance.toFixed(2)})² = ${Math.pow(adjustedDistance, 2).toFixed(2)}%\n`;
        } else { // commercial
            output += `Surface > ${surfacesDisponibles[surfacesDisponibles.length - 1]}m² et DL ≥ 1,2m: formule de la moitié du carré de la distance:\n`;
            output += `Pourcentage = 0,5 × (DL)² = 0,5 × (${adjustedDistance.toFixed(2)})² = ${(0.5 * Math.pow(adjustedDistance, 2)).toFixed(2)}%\n`;
        }
        
        // Appliquer la majoration si nécessaire
        let resultat = usage === "habitation" ? Math.pow(adjustedDistance, 2) : 0.5 * Math.pow(adjustedDistance, 2);
        if (avecGicleurs || glassBrick) {
            output += `\nAvec majoration ${avecGicleurs && glassBrick ? "pour gicleurs et briques de verre/verre armé" : 
                       avecGicleurs ? "pour gicleurs" : "pour briques de verre/verre armé"} (x2): ${Math.min(100, resultat * 2).toFixed(2)}%\n`;
        }
        
        return output;
    }
    
    if (extrapolationDistance && !extrapolationSurface) {
        // Cas d'extrapolation pour distance uniquement
        output += "Extrapolation pour distance limitative entre 0 et 1,2m:\n";
        output += `- À distance = 0m: pourcentage = 0% (toujours)\n`;
        
        // Trouver la surface encadrante pour la façade de rayonnement
        let keyInf;
        if (surface <= surfacesDisponibles[0]) {
            keyInf = surfacesDisponibles[0].toString();
        } else if (surface > surfacesDisponibles[surfacesDisponibles.length - 1]) {
            keyInf = ">100";
        } else {
            for (let i = 0; i < surfacesDisponibles.length - 1; i++) {
                if (surface > surfacesDisponibles[i] && surface <= surfacesDisponibles[i + 1]) {
                    keyInf = surfacesDisponibles[i].toString();
                    break;
                }
            }
        }
        
        const pourcentageDistanceMin = tableau.surfaces[keyInf][1]; // Index 1 = 1.2m
        output += `- À distance = 1,2m: pourcentage = ${pourcentageDistanceMin}% (pour surface de ${keyInf}m²)\n`;
        
        // Calculer l'extrapolation
        const pente = pourcentageDistanceMin / 1.2; // Pente = % à 1.2m divisé par 1.2
        const pourcentageExtrapole = pente * adjustedDistance;
        
        output += `Formule d'extrapolation linéaire: % = (${pourcentageDistanceMin} ÷ 1,2) × ${adjustedDistance.toFixed(2)} = ${pourcentageExtrapole.toFixed(2)}%\n\n`;
        
        if (avecGicleurs || glassBrick) {
            const pourcentageAvecMajoration = Math.min(100, pourcentageExtrapole * 2);
            output += `Avec majoration ${avecGicleurs && glassBrick ? "pour gicleurs et briques de verre/verre armé" : 
                       avecGicleurs ? "pour gicleurs" : "pour briques de verre/verre armé"} (×2): ${pourcentageAvecMajoration.toFixed(2)}%\n`;
        }
        
        return output;
    }
    
    if (extrapolationSurface && !extrapolationDistance) {
        // Cas d'extrapolation pour surface uniquement
        output += "Extrapolation pour surface de façade inférieure à 30m²:\n";
        
        const distanceInferieureIndex = tableau.distances.indexOf(Math.max(...tableau.distances.filter(d => d <= adjustedDistance)));
        const pourcentageSurfMin = tableau.surfaces[surfacesDisponibles[0]][distanceInferieureIndex];
        const pourcentageSurfSupMin = tableau.surfaces[surfacesDisponibles[1]][distanceInferieureIndex];
            
        output += `- Pour surface = ${surfacesDisponibles[0]}m²: pourcentage = ${pourcentageSurfMin}%\n`;
        output += `- Pour surface = ${surfacesDisponibles[1]}m²: pourcentage = ${pourcentageSurfSupMin}%\n`;
        
        // Extrapolation - plus la surface est petite, plus le pourcentage permis est élevé
        const ratio = surfacesDisponibles[0] / surface;
        const facteur = Math.sqrt(ratio);
        const tendance = (pourcentageSurfMin - pourcentageSurfSupMin) * (facteur - 1);
        const pourcentageExtrapole = Math.min(100, pourcentageSurfMin + tendance);
        
        output += `Formule d'extrapolation pour surface plus petite: % = ${pourcentageSurfMin} + (${pourcentageSurfMin} - ${pourcentageSurfSupMin}) × (√(${surfacesDisponibles[0]} ÷ ${surface.toFixed(2)}) - 1)\n`;
        output += `% = ${pourcentageSurfMin} + ${tendance.toFixed(2)} = ${pourcentageExtrapole.toFixed(2)}%\n\n`;
        
        if (avecGicleurs || glassBrick) {
            const pourcentageAvecMajoration = Math.min(100, pourcentageExtrapole * 2);
            output += `Avec majoration ${avecGicleurs && glassBrick ? "pour gicleurs et briques de verre/verre armé" : 
                       avecGicleurs ? "pour gicleurs" : "pour briques de verre/verre armé"} (×2): ${pourcentageAvecMajoration.toFixed(2)}%\n`;
        }
        
        return output;
    }
    
    if (extrapolationSurface && extrapolationDistance) {
        // Cas de double extrapolation (surface et distance)
        output += "Double extrapolation (distance et surface):\n";
        output += "1) Extrapolation pour la plus petite surface du tableau (30m²) avec distance entre 0 et 1,2m:\n";
        output += `- À distance = 0m: pourcentage = 0% (toujours)\n`;
        
        const pourcentageDistMinSurfMin = tableau.surfaces[surfacesDisponibles[0]][1]; // Index 1 = 1.2m
        output += `- À distance = 1,2m: pourcentage = ${pourcentageDistMinSurfMin}% (pour surface de ${surfacesDisponibles[0]}m²)\n`;
        
        // Extrapolation distance pour surface min
        const pente1 = pourcentageDistMinSurfMin / 1.2;
        const pourcentageEtape1 = pente1 * adjustedDistance;
        
        output += `Étape 1 - Extrapolation distance: % = (${pourcentageDistMinSurfMin} ÷ 1,2) × ${adjustedDistance.toFixed(2)} = ${pourcentageEtape1.toFixed(2)}%\n\n`;
        
        output += "2) Extrapolation pour la surface réelle à partir du résultat précédent:\n";
        
        const pourcentageSurfSupMin = tableau.surfaces[surfacesDisponibles[1]][1]; // 1.2m pour deuxième surface du tableau
            
        // Extrapolation distance pour surface sup min
        const pente2 = pourcentageSurfSupMin / 1.2;
        const pourcentageEtape1bis = pente2 * adjustedDistance;
        
        output += `- Pour surface = ${surfacesDisponibles[1]}m² à la distance ${adjustedDistance.toFixed(2)}m: % = ${pourcentageEtape1bis.toFixed(2)}%\n`;
        
        // Extrapolation surface
        const ratio = surfacesDisponibles[0] / surface;
        const facteur = Math.sqrt(ratio);
        const pourcentageDistSupMin = (pourcentageSurfSupMin / 1.2) * adjustedDistance;
        const tendance = (pourcentageEtape1 - pourcentageDistSupMin) * (facteur - 1);
        const pourcentageExtrapole = Math.min(100, pourcentageEtape1 + tendance);
        
        output += `Étape 2 - Extrapolation surface: % = ${pourcentageEtape1.toFixed(2)} + (${pourcentageEtape1.toFixed(2)} - ${pourcentageDistSupMin.toFixed(2)}) × (√(${surfacesDisponibles[0]} ÷ ${surface.toFixed(2)}) - 1)\n`;
        output += `% = ${pourcentageEtape1.toFixed(2)} + ${tendance.toFixed(2)} = ${pourcentageExtrapole.toFixed(2)}%\n\n`;
        
        if (avecGicleurs || glassBrick) {
            const pourcentageAvecMajoration = Math.min(100, pourcentageExtrapole * 2);
            output += `Avec majoration ${avecGicleurs && glassBrick ? "pour gicleurs et briques de verre/verre armé" : 
                       avecGicleurs ? "pour gicleurs" : "pour briques de verre/verre armé"} (×2): ${pourcentageAvecMajoration.toFixed(2)}%\n`;
        }
        
        return output;
    }
    
    // Trouver les distances encadrantes
    const distancesEncadrantes = trouverValeurEncadrantes(adjustedDistance, tableau.distances);
    const distanceInferieure = distancesEncadrantes.inferieure;
    const distanceSuperieure = distancesEncadrantes.superieure;
    const distanceInferieureIndex = tableau.distances.indexOf(distanceInferieure);
    const distanceSuperieureIndex = tableau.distances.indexOf(distanceSuperieure);
    
    // Trouver les surfaces encadrantes
    let surfaceInferieure, surfaceSuperieure;
    let keyInf, keySup;
    
    if (surface <= surfacesDisponibles[0]) {
        surfaceInferieure = surfaceSuperieure = surfacesDisponibles[0];
        keyInf = keySup = surfacesDisponibles[0].toString();
    } else if (surface > surfacesDisponibles[surfacesDisponibles.length - 1]) {
        surfaceInferieure = surfacesDisponibles[surfacesDisponibles.length - 1];
        surfaceSuperieure = Infinity;
        keyInf = surfacesDisponibles[surfacesDisponibles.length - 1].toString();
        keySup = ">100";
    } else {
        for (let i = 0; i < surfacesDisponibles.length - 1; i++) {
            if (surface > surfacesDisponibles[i] && surface <= surfacesDisponibles[i + 1]) {
                surfaceInferieure = surfacesDisponibles[i];
                surfaceSuperieure = surfacesDisponibles[i + 1];
                keyInf = surfaceInferieure.toString();
                keySup = surfaceSuperieure.toString();
                break;
            }
        }
    }
    
    // ÉTAPE 1: Interpolation selon la DL inférieure - MODIFIÉE
    let pourcentageDistanceInferieure;
    output += "Étape 1: Interpolation selon la DL encadrante inférieure (" + distanceInferieure + "m):\n";
    
    if (keyInf === keySup) {
        pourcentageDistanceInferieure = tableau.surfaces[keyInf][distanceInferieureIndex];
        output += `À DL de ${distanceInferieure}m et surface max. de ${keyInf}m²: ${pourcentageDistanceInferieure}%\n\n`;
    } else {
        const pourcentageDistInfSurfInf = tableau.surfaces[keyInf][distanceInferieureIndex];
        const pourcentageDistInfSurfSup = tableau.surfaces[keySup][distanceInferieureIndex];
        
        output += `À DL de ${distanceInferieure}m et surface max. de ${keyInf}m²: ${pourcentageDistInfSurfInf}%\n`;
        output += `À DL de ${distanceInferieure}m et surface max. de ${keySup}m²: ${pourcentageDistInfSurfSup}%\n`;
        
        pourcentageDistanceInferieure = pourcentageDistInfSurfSup + 
            ((surface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageDistInfSurfInf - pourcentageDistInfSurfSup);
        
        output += `${pourcentageDistInfSurfSup} + (${surface.toFixed(2)} – ${surfaceInferieure}) / (${surfaceSuperieure} – ${surfaceInferieure}) x (${pourcentageDistInfSurfInf} – ${pourcentageDistInfSurfSup}) = `;
        output += `${pourcentageDistInfSurfSup} + ${((surface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure) * (pourcentageDistInfSurfInf - pourcentageDistInfSurfSup)).toFixed(3)} = ${pourcentageDistanceInferieure.toFixed(2)} %\n\n`;
    }
    
    // Si les distances sont identiques, pas besoin d'interpolation supplémentaire
    if (distanceInferieure === distanceSuperieure) {
        let resultat = pourcentageDistanceInferieure;
        if (avecGicleurs || glassBrick) {
            output += `Résultat final: ${pourcentageDistanceInferieure.toFixed(2)}%\n`;
            output += `Avec majoration ${avecGicleurs && glassBrick ? "pour gicleurs et briques de verre/verre armé" : 
                       avecGicleurs ? "pour gicleurs" : "pour briques de verre/verre armé"} (x2): ${Math.min(100, resultat * 2).toFixed(2)}%\n`;
        } else {
            output += `Résultat final: ${pourcentageDistanceInferieure.toFixed(2)}%\n`;
        }
        return output;
    }
    
    // ÉTAPE 2: Interpolation selon la DL supérieure - MODIFIÉE
    let pourcentageDistanceSuperieure;
    output += "Étape 2: Interpolation selon la DL encadrante supérieure (" + distanceSuperieure + "m):\n";
    
    if (keyInf === keySup) {
        pourcentageDistanceSuperieure = tableau.surfaces[keyInf][distanceSuperieureIndex];
        output += `À DL de ${distanceSuperieure}m et surface max. de ${keyInf}m²: ${pourcentageDistanceSuperieure}%\n\n`;
    } else {
        const pourcentageDistSupSurfInf = tableau.surfaces[keyInf][distanceSuperieureIndex];
        const pourcentageDistSupSurfSup = tableau.surfaces[keySup][distanceSuperieureIndex];
        
        output += `À DL de ${distanceSuperieure}m et surface max. de ${keyInf}m²: ${pourcentageDistSupSurfInf}%\n`;
        output += `À DL de ${distanceSuperieure}m et surface max. de ${keySup}m²: ${pourcentageDistSupSurfSup}%\n`;
        
        pourcentageDistanceSuperieure = pourcentageDistSupSurfSup + 
            ((surface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageDistSupSurfInf - pourcentageDistSupSurfSup);
        
        output += `${pourcentageDistSupSurfSup} + (${surface.toFixed(2)} – ${surfaceInferieure}) / (${surfaceSuperieure} – ${surfaceInferieure}) x (${pourcentageDistSupSurfInf} – ${pourcentageDistSupSurfSup}) = `;
        output += `${pourcentageDistSupSurfSup} + ${((surface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure) * (pourcentageDistSupSurfInf - pourcentageDistSupSurfSup)).toFixed(3)} = ${pourcentageDistanceSuperieure.toFixed(2)} %\n\n`;
    }
    
    // ÉTAPE 3: Interpolation finale entre les deux résultats d'interpolation précédents
    output += "Étape 3: Interpolation selon les résultats obtenus des deux interpolations précédentes:\n";
    
    let pourcentageFinal = pourcentageDistanceInferieure + 
        ((adjustedDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
        (pourcentageDistanceSuperieure - pourcentageDistanceInferieure);
    
    output += `${pourcentageDistanceInferieure.toFixed(2)} + (${adjustedDistance.toFixed(2)} – ${distanceInferieure}) / (${distanceSuperieure} – ${distanceInferieure}) x (${pourcentageDistanceSuperieure.toFixed(2)} – ${pourcentageDistanceInferieure.toFixed(2)}) = `;
    output += `${pourcentageDistanceInferieure.toFixed(2)} + ${((adjustedDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure) * (pourcentageDistanceSuperieure - pourcentageDistanceInferieure)).toFixed(2)} = ${pourcentageFinal.toFixed(2)} %\n`;
    
    // Appliquer la majoration si nécessaire
    if (avecGicleurs || glassBrick) {
        output += `\nAvec majoration ${avecGicleurs && glassBrick ? "pour gicleurs et briques de verre/verre armé" : 
                   avecGicleurs ? "pour gicleurs" : "pour briques de verre/verre armé"} (x2): ${Math.min(100, pourcentageFinal * 2).toFixed(2)}%\n`;
    }
    
    return output;
}

// Fonction pour formater les calculs d'interpolation pour 9.10.15 - MISE À JOUR pour inclure l'extrapolation
function format91015CalculationSteps() {
    const housingType = document.getElementById('housing_type_91015').value;
    let limitingDistance = parseFloat(document.getElementById('distance_91015').value);
    const surface = parseFloat(document.getElementById('surface_91015').value);
    const sprinklersOption = document.getElementById('sprinklers_91015').value;
    const avecGicleurs = sprinklersOption === "complete";
    const glassBrick = document.getElementById('glass_brick_91015').checked;
    const response = document.getElementById('response_91015').checked;
    
    // Ajustement pour le délai d'intervention
    const adjustedDistance = response ? limitingDistance / 2 : limitingDistance;
    
    // Préparer le texte formaté
    let output = "Selon les données du Tableau 9.10.15.4.:\n\n";
    
    // Paramètres
    output += "Paramètres indiqués:\n";
    output += `DL: ${adjustedDistance.toFixed(2)}m\n`;
    output += `Surface de la FDR: ${surface.toFixed(2)}m²\n\n`;
    
    // Vérifier si extrapolation nécessaire
    const surfacesDisponibles = Object.keys(tableau91015.surfaces).filter(s => s !== ">100").map(Number);
    const extrapolationSurface = surface < surfacesDisponibles[0];
    const extrapolationDistance = adjustedDistance > 0 && adjustedDistance < tableau91015.distances.find(d => d > 0);
    
    // Cas particulier: Formule du carré de la distance
    if (surface > surfacesDisponibles[surfacesDisponibles.length - 1] && adjustedDistance >= 1.2) {
        output += `Surface > ${surfacesDisponibles[surfacesDisponibles.length - 1]}m² et DL ≥ 1,2m: formule du carré de la distance:\n`;
        output += `Pourcentage = (DL)² = (${adjustedDistance.toFixed(2)})² = ${Math.pow(adjustedDistance, 2).toFixed(2)}%\n`;
        
        // Appliquer la majoration si nécessaire
        let resultat = Math.pow(adjustedDistance, 2);
        if (avecGicleurs || glassBrick) {
            output += `\nAvec majoration ${avecGicleurs && glassBrick ? "pour gicleurs et briques de verre/verre armé" : 
                       avecGicleurs ? "pour gicleurs" : "pour briques de verre/verre armé"} (x2): ${Math.min(100, resultat * 2).toFixed(2)}%\n`;
        }
        
        return output;
    }
    
    if (extrapolationDistance && !extrapolationSurface) {
        // Cas d'extrapolation pour distance uniquement
        output += "Extrapolation pour distance limitative entre 0 et 1,2m:\n";
        output += `- À distance = 0m: pourcentage = 0% (toujours)\n`;
        
        // Trouver la surface encadrante pour la façade de rayonnement
        let keyInf;
        if (surface <= surfacesDisponibles[0]) {
            keyInf = surfacesDisponibles[0].toString();
        } else if (surface > surfacesDisponibles[surfacesDisponibles.length - 1]) {
            keyInf = ">100";
        } else {
            for (let i = 0; i < surfacesDisponibles.length - 1; i++) {
                if (surface > surfacesDisponibles[i] && surface <= surfacesDisponibles[i + 1]) {
                    keyInf = surfacesDisponibles[i].toString();
                    break;
                }
            }
        }
        
        const pourcentageDistanceMin = tableau91015.surfaces[keyInf][1]; // Index 1 = 1.2m
        output += `- À distance = 1,2m: pourcentage = ${pourcentageDistanceMin}% (pour surface de ${keyInf}m²)\n`;
        
        // Calculer l'extrapolation
        const pente = pourcentageDistanceMin / 1.2; // Pente = % à 1.2m divisé par 1.2
        const pourcentageExtrapole = pente * adjustedDistance;
        
        output += `Formule d'extrapolation linéaire: % = (${pourcentageDistanceMin} ÷ 1,2) × ${adjustedDistance.toFixed(2)} = ${pourcentageExtrapole.toFixed(2)}%\n\n`;
        
        if (avecGicleurs || glassBrick) {
            const pourcentageAvecMajoration = Math.min(100, pourcentageExtrapole * 2);
            output += `Avec majoration ${avecGicleurs && glassBrick ? "pour gicleurs et briques de verre/verre armé" : 
                       avecGicleurs ? "pour gicleurs" : "pour briques de verre/verre armé"} (×2): ${pourcentageAvecMajoration.toFixed(2)}%\n`;
        }
        
        return output;
    }
    
    if (extrapolationSurface && !extrapolationDistance) {
        // Cas d'extrapolation pour surface uniquement
        output += "Extrapolation pour surface de façade inférieure à 30m²:\n";
        
        const distanceInferieureIndex = tableau91015.distances.indexOf(Math.max(...tableau91015.distances.filter(d => d <= adjustedDistance)));
        const pourcentageSurfMin = tableau91015.surfaces[surfacesDisponibles[0]][distanceInferieureIndex];
        const pourcentageSurfSupMin = tableau91015.surfaces[surfacesDisponibles[1]][distanceInferieureIndex];
            
        output += `- Pour surface = ${surfacesDisponibles[0]}m²: pourcentage = ${pourcentageSurfMin}%\n`;
        output += `- Pour surface = ${surfacesDisponibles[1]}m²: pourcentage = ${pourcentageSurfSupMin}%\n`;
        
        // Extrapolation - plus la surface est petite, plus le pourcentage permis est élevé
        const ratio = surfacesDisponibles[0] / surface;
        const facteur = Math.sqrt(ratio);
        const tendance = (pourcentageSurfMin - pourcentageSurfSupMin) * (facteur - 1);
        const pourcentageExtrapole = Math.min(100, pourcentageSurfMin + tendance);
        
        output += `Formule d'extrapolation pour surface plus petite: % = ${pourcentageSurfMin} + (${pourcentageSurfMin} - ${pourcentageSurfSupMin}) × (√(${surfacesDisponibles[0]} ÷ ${surface.toFixed(2)}) - 1)\n`;
        output += `% = ${pourcentageSurfMin} + ${tendance.toFixed(2)} = ${pourcentageExtrapole.toFixed(2)}%\n\n`;
        
        if (avecGicleurs || glassBrick) {
            const pourcentageAvecMajoration = Math.min(100, pourcentageExtrapole * 2);
            output += `Avec majoration ${avecGicleurs && glassBrick ? "pour gicleurs et briques de verre/verre armé" : 
                       avecGicleurs ? "pour gicleurs" : "pour briques de verre/verre armé"} (×2): ${pourcentageAvecMajoration.toFixed(2)}%\n`;
        }
        
        return output;
    }
    
    if (extrapolationSurface && extrapolationDistance) {
        // Cas de double extrapolation (surface et distance)
        output += "Double extrapolation (distance et surface):\n";
        output += "1) Extrapolation pour la plus petite surface du tableau (30m²) avec distance entre 0 et 1,2m:\n";
        output += `- À distance = 0m: pourcentage = 0% (toujours)\n`;
        
        const pourcentageDistMinSurfMin = tableau91015.surfaces[surfacesDisponibles[0]][1]; // Index 1 = 1.2m
        output += `- À distance = 1,2m: pourcentage = ${pourcentageDistMinSurfMin}% (pour surface de ${surfacesDisponibles[0]}m²)\n`;
        
        // Extrapolation distance pour surface min
        const pente1 = pourcentageDistMinSurfMin / 1.2;
        const pourcentageEtape1 = pente1 * adjustedDistance;
        
        output += `Étape 1 - Extrapolation distance: % = (${pourcentageDistMinSurfMin} ÷ 1,2) × ${adjustedDistance.toFixed(2)} = ${pourcentageEtape1.toFixed(2)}%\n\n`;
        
        output += "2) Extrapolation pour la surface réelle à partir du résultat précédent:\n";
        
        const pourcentageSurfSupMin = tableau91015.surfaces[surfacesDisponibles[1]][1]; // 1.2m pour deuxième surface du tableau
            
        // Extrapolation distance pour surface sup min
        const pente2 = pourcentageSurfSupMin / 1.2;
        const pourcentageEtape1bis = pente2 * adjustedDistance;
        
        output += `- Pour surface = ${surfacesDisponibles[1]}m² à la distance ${adjustedDistance.toFixed(2)}m: % = ${pourcentageEtape1bis.toFixed(2)}%\n`;
        
        // Extrapolation surface
        const ratio = surfacesDisponibles[0] / surface;
        const facteur = Math.sqrt(ratio);
        const pourcentageDistSupMin = (pourcentageSurfSupMin / 1.2) * adjustedDistance;
        const tendance = (pourcentageEtape1 - pourcentageDistSupMin) * (facteur - 1);
        const pourcentageExtrapole = Math.min(100, pourcentageEtape1 + tendance);
        
        output += `Étape 2 - Extrapolation surface: % = ${pourcentageEtape1.toFixed(2)} + (${pourcentageEtape1.toFixed(2)} - ${pourcentageDistSupMin.toFixed(2)}) × (√(${surfacesDisponibles[0]} ÷ ${surface.toFixed(2)}) - 1)\n`;
        output += `% = ${pourcentageEtape1.toFixed(2)} + ${tendance.toFixed(2)} = ${pourcentageExtrapole.toFixed(2)}%\n\n`;
        
        if (avecGicleurs || glassBrick) {
            const pourcentageAvecMajoration = Math.min(100, pourcentageExtrapole * 2);
            output += `Avec majoration ${avecGicleurs && glassBrick ? "pour gicleurs et briques de verre/verre armé" : 
                       avecGicleurs ? "pour gicleurs" : "pour briques de verre/verre armé"} (×2): ${pourcentageAvecMajoration.toFixed(2)}%\n`;
        }
        
        return output;
    }
    
    // Trouver les distances encadrantes
    const distancesEncadrantes = trouverValeurEncadrantes(adjustedDistance, tableau91015.distances);
    const distanceInferieure = distancesEncadrantes.inferieure;
    const distanceSuperieure = distancesEncadrantes.superieure;
    const distanceInferieureIndex = tableau91015.distances.indexOf(distanceInferieure);
    const distanceSuperieureIndex = tableau91015.distances.indexOf(distanceSuperieure);
    
    // Trouver les surfaces encadrantes
    let surfaceInferieure, surfaceSuperieure;
    let keyInf, keySup;
    
    if (surface <= surfacesDisponibles[0]) {
        surfaceInferieure = surfaceSuperieure = surfacesDisponibles[0];
        keyInf = keySup = surfacesDisponibles[0].toString();
    } else if (surface > surfacesDisponibles[surfacesDisponibles.length - 1]) {
        surfaceInferieure = surfacesDisponibles[surfacesDisponibles.length - 1];
        surfaceSuperieure = Infinity;
        keyInf = surfacesDisponibles[surfacesDisponibles.length - 1].toString();
        keySup = ">100";
    } else {
        for (let i = 0; i < surfacesDisponibles.length - 1; i++) {
            if (surface > surfacesDisponibles[i] && surface <= surfacesDisponibles[i + 1]) {
                surfaceInferieure = surfacesDisponibles[i];
                surfaceSuperieure = surfacesDisponibles[i + 1];
                keyInf = surfaceInferieure.toString();
                keySup = surfaceSuperieure.toString();
                break;
            }
        }
    }
    
    // ÉTAPE 1: Interpolation selon la DL inférieure
    let pourcentageDistanceInferieure;
    output += "Étape 1: Interpolation selon la DL encadrante inférieure (" + distanceInferieure + "m):\n";
    
    if (keyInf === keySup) {
        pourcentageDistanceInferieure = tableau91015.surfaces[keyInf][distanceInferieureIndex];
        output += `À DL de ${distanceInferieure}m et surface max. de ${keyInf}m²: ${pourcentageDistanceInferieure}%\n\n`;
    } else {
        const pourcentageDistInfSurfInf = tableau91015.surfaces[keyInf][distanceInferieureIndex];
        const pourcentageDistInfSurfSup = tableau91015.surfaces[keySup][distanceInferieureIndex];
        
        output += `À DL de ${distanceInferieure}m et surface max. de ${keyInf}m²: ${pourcentageDistInfSurfInf}%\n`;
        output += `À DL de ${distanceInferieure}m et surface max. de ${keySup}m²: ${pourcentageDistInfSurfSup}%\n`;
        
        pourcentageDistanceInferieure = pourcentageDistInfSurfSup + 
            ((surface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageDistInfSurfInf - pourcentageDistInfSurfSup);
        
        output += `${pourcentageDistInfSurfSup} + (${surface.toFixed(2)} – ${surfaceInferieure}) / (${surfaceSuperieure} – ${surfaceInferieure}) x (${pourcentageDistInfSurfInf} – ${pourcentageDistInfSurfSup}) = `;
        output += `${pourcentageDistInfSurfSup} + ${((surface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure) * (pourcentageDistInfSurfInf - pourcentageDistInfSurfSup)).toFixed(3)} = ${pourcentageDistanceInferieure.toFixed(2)} %\n\n`;
    }
    
    // Si les distances sont identiques, pas besoin d'interpolation supplémentaire
    if (distanceInferieure === distanceSuperieure) {
        let resultat = pourcentageDistanceInferieure;
        if (avecGicleurs || glassBrick) {
            output += `Résultat final: ${pourcentageDistanceInferieure.toFixed(2)}%\n`;
            output += `Avec majoration ${avecGicleurs && glassBrick ? "pour gicleurs et briques de verre/verre armé" : 
                       avecGicleurs ? "pour gicleurs" : "pour briques de verre/verre armé"} (x2): ${Math.min(100, resultat * 2).toFixed(2)}%\n`;
        } else {
            output += `Résultat final: ${pourcentageDistanceInferieure.toFixed(2)}%\n`;
        }
        return output;
    }
    
    // ÉTAPE 2: Interpolation selon la DL supérieure
    let pourcentageDistanceSuperieure;
    output += "Étape 2: Interpolation selon la DL encadrante supérieure (" + distanceSuperieure + "m):\n";
    
    if (keyInf === keySup) {
        pourcentageDistanceSuperieure = tableau91015.surfaces[keyInf][distanceSuperieureIndex];
        output += `À DL de ${distanceSuperieure}m et surface max. de ${keyInf}m²: ${pourcentageDistanceSuperieure}%\n\n`;
    } else {
        const pourcentageDistSupSurfInf = tableau91015.surfaces[keyInf][distanceSuperieureIndex];
        const pourcentageDistSupSurfSup = tableau91015.surfaces[keySup][distanceSuperieureIndex];
        
        output += `À DL de ${distanceSuperieure}m et surface max. de ${keyInf}m²: ${pourcentageDistSupSurfInf}%\n`;
        output += `À DL de ${distanceSuperieure}m et surface max. de ${keySup}m²: ${pourcentageDistSupSurfSup}%\n`;
        
        pourcentageDistanceSuperieure = pourcentageDistSupSurfSup + 
            ((surface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure)) * 
            (pourcentageDistSupSurfInf - pourcentageDistSupSurfSup);
        
        output += `${pourcentageDistSupSurfSup} + (${surface.toFixed(2)} – ${surfaceInferieure}) / (${surfaceSuperieure} – ${surfaceInferieure}) x (${pourcentageDistSupSurfInf} – ${pourcentageDistSupSurfSup}) = `;
        output += `${pourcentageDistSupSurfSup} + ${((surface - surfaceInferieure) / (surfaceSuperieure - surfaceInferieure) * (pourcentageDistSupSurfInf - pourcentageDistSupSurfSup)).toFixed(3)} = ${pourcentageDistanceSuperieure.toFixed(2)} %\n\n`;
    }
    
    // ÉTAPE 3: Interpolation finale
    output += "Étape 3: Interpolation selon les résultats obtenus des deux interpolations précédentes:\n";
    
    let pourcentageFinal = pourcentageDistanceInferieure + 
        ((adjustedDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure)) * 
        (pourcentageDistanceSuperieure - pourcentageDistanceInferieure);
    
    output += `${pourcentageDistanceInferieure.toFixed(2)} + (${adjustedDistance.toFixed(2)} – ${distanceInferieure}) / (${distanceSuperieure} – ${distanceInferieure}) x (${pourcentageDistanceSuperieure.toFixed(2)} – ${pourcentageDistanceInferieure.toFixed(2)}) = `;
    output += `${pourcentageDistanceInferieure.toFixed(2)} + ${((adjustedDistance - distanceInferieure) / (distanceSuperieure - distanceInferieure) * (pourcentageDistanceSuperieure - pourcentageDistanceInferieure)).toFixed(2)} = ${pourcentageFinal.toFixed(2)} %\n`;
    
    // Appliquer la majoration si nécessaire
    if (avecGicleurs || glassBrick) {
        output += `\nAvec majoration ${avecGicleurs && glassBrick ? "pour gicleurs et briques de verre/verre armé" : 
                   avecGicleurs ? "pour gicleurs" : "pour briques de verre/verre armé"} (x2): ${Math.min(100, pourcentageFinal * 2).toFixed(2)}%\n`;
    }
    
    return output;
}

// Fonction pour copier le contenu dans le presse-papier avec format détaillé
function copyToClipboard(elementId) {
    let text = "";
    
    // Déterminer quelle méthode utiliser
    if (elementId === 'cnb-result') {
        text = formatCNBCalculationSteps();
    } else if (elementId === 'method91014-result') {
        text = format91014CalculationSteps();
    } else if (elementId === 'method91015-result') {
        text = format91015CalculationSteps();
    } else {
        // Fallback au comportement d'origine si l'ID n'est pas reconnu
        const element = document.getElementById(elementId);
        text = element.innerText;
    }
    
    navigator.clipboard.writeText(text)
        .then(() => {
            // Pour "method91014-result" ou "method91015-result", extrait "91014" ou "91015"
            let buttonId;
            if (elementId.startsWith('method')) {
                buttonId = elementId.split('-')[0].replace('method', '');
            } else {
                buttonId = elementId.split('-')[0];
            }
            
            const originalButtonText = document.getElementById(`copy_${buttonId}`).innerHTML;
            document.getElementById(`copy_${buttonId}`).innerHTML = "✓ Copié!";
            setTimeout(() => {
                document.getElementById(`copy_${buttonId}`).innerHTML = originalButtonText;
            }, 2000);
        })
        .catch(err => {
            console.error('Impossible de copier le texte:', err);
        });
}

// Fonction pour gérer l'appui sur la touche Enter
function handleEnterKey(event, calculationFunction) {
    if (event.key === "Enter") {
        calculationFunction();
    }
}
